<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKS BOMA Tabulator</title>
    
    <!-- SheetJS Library for reading uploaded files -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <!-- ExcelJS Library for writing formatted Excel (preserves template styles) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --hks-grey: #7B797D;
            --hks-dark: #3a3a3a;
            --hks-light: #f5f5f5;
            --accent: #2196F3;
            --success: #4CAF50;
            --warning: #FF9800;
            --error: #f44336;
            --border: #e0e0e0;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: var(--hks-grey);
            color: white;
            padding: 30px 40px;
            border-bottom: 4px solid var(--hks-dark);
        }
        
        .header h1 { font-size: 32px; font-weight: 600; margin-bottom: 8px; }
        .header p { opacity: 0.95; font-size: 15px; }
        
        .content { padding: 25px; }
        
        .step { margin-bottom: 20px; padding-bottom: 20px; border-bottom: 1px solid var(--border); }
        .step:last-child { border-bottom: none; }
        
        .step-header { display: flex; align-items: center; margin-bottom: 8px; }
        .step-number {
            width: 40px; height: 40px;
            background: var(--hks-grey);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 15px;
            font-size: 18px;
        }
        .step-title { font-size: 22px; color: var(--hks-dark); font-weight: 600; }
        
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 50px;
            text-align: center;
            background: var(--hks-light);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-zone:hover { border-color: var(--accent); background: #e3f2fd; }
        .upload-icon { font-size: 56px; margin-bottom: 15px; }
        .upload-text { font-size: 18px; color: var(--hks-dark); margin-bottom: 8px; font-weight: 500; }
        input[type="file"] { display: none; }
        
        .file-info {
            display: none;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 8px;
            margin-top: 20px;
        }
        .file-info.active { display: flex; }
        
        .mapping-container {
            background: var(--hks-light);
            border-radius: 6px;
            padding: 8px;
            max-height: 65vh;
            overflow-y: auto;
        }
        
        .floor-item {
            background: white;
            padding: 5px 10px;
            margin-bottom: 3px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            cursor: grab;
        }
        .floor-item:hover {
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .floor-item.dragging { opacity: 0.5; cursor: grabbing; }
        .floor-item.drag-over { border-top: 3px solid var(--accent); }
        
        .drag-handle {
            cursor: grab;
            padding: 0 2px;
            color: var(--hks-grey);
            font-size: 12px;
        }
        
        .floor-label {
            min-width: 220px;
            font-weight: 500;
            color: var(--hks-dark);
            padding: 4px 8px;
            background: var(--hks-light);
            border-radius: 3px;
            font-size: 12px;
        }
        
        .floor-input {
            flex: 1;
            padding: 4px 8px;
            border: 1px solid var(--border);
            border-radius: 3px;
            font-size: 12px;
            font-family: Arial, sans-serif;
        }
        .floor-input:focus {
            outline: none;
            border-color: var(--accent);
        }
        
        .floor-actions {
            display: flex;
            gap: 3px;
            flex-wrap: wrap;
        }
        .action-btn {
            padding: 3px 6px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 3px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.2s ease;
        }
        .action-btn:hover { background: var(--hks-light); }
        .action-btn.remove:hover { background: #ffebee; border-color: var(--error); color: var(--error); }
        
        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: #1976D2; transform: translateY(-2px); }
        .btn-success { background: var(--success); color: white; }
        .btn-success:hover { background: #45a049; transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .hidden { display: none !important; }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid var(--accent);
            padding: 8px 12px;
            margin: 8px 0;
            border-radius: 4px;
            font-size: 13px;
        }
        
        .stats-grid {
            display: flex;
            gap: 15px;
            margin: 8px 0;
        }
        .stat-card {
            background: white;
            padding: 6px 12px;
            border-radius: 4px;
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .stat-value {
            font-size: 18px;
            font-weight: 600;
            color: var(--hks-grey);
        }
        .stat-label {
            font-size: 11px;
            color: #666;
        }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Project Info Styles */
        .project-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .project-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .project-field label {
            font-weight: 500;
            color: var(--hks-dark);
            font-size: 14px;
        }
        .project-field input {
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 15px;
            font-family: Arial, sans-serif;
        }
        .project-field input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .project-field .hint {
            font-size: 12px;
            color: #666;
        }
        
        /* Area Type Filter Styles */
        .area-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
            gap: 6px;
            margin: 10px 0;
        }
        .area-type-item {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 10px;
            background: white;
            border: 1px solid var(--border);
            border-radius: 4px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .area-type-item:hover {
            border-color: var(--accent);
            background: #f5f9ff;
        }
        .area-type-item input[type="checkbox"] {
            width: 16px;
            height: 16px;
            cursor: pointer;
        }
        .area-type-item label {
            cursor: pointer;
            font-size: 13px;
            font-weight: 500;
        }
        .area-type-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .area-type-buttons button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .area-type-buttons button:hover {
            background: var(--hks-light);
        }
        
        /* Area Category Styles */
        .area-category {
            margin-bottom: 20px;
            border-radius: 8px;
            overflow: hidden;
            border: 1px solid var(--border);
        }
        .area-category-header {
            padding: 10px 15px;
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .area-category-header.standard {
            background: #e8f5e9;
            color: #2e7d32;
            border-bottom: 1px solid #c8e6c9;
        }
        .area-category-header.nonstandard {
            background: #fff3e0;
            color: #e65100;
            border-bottom: 1px solid #ffe0b2;
        }
        .area-category-actions {
            display: flex;
            gap: 8px;
        }
        .area-category-actions button {
            padding: 4px 10px;
            border: 1px solid rgba(0,0,0,0.2);
            background: rgba(255,255,255,0.7);
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
        }
        .area-category-actions button:hover {
            background: rgba(255,255,255,1);
        }
        .area-category .area-type-grid {
            padding: 8px 12px;
            margin: 0;
            background: white;
        }
        .nonstandard-note {
            padding: 8px 15px;
            background: #fffde7;
            font-size: 12px;
            color: #666;
            margin: 0;
            border-top: 1px solid #fff9c4;
        }
        
        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-overlay.active {
            display: flex;
        }
        .modal {
            background: white;
            border-radius: 12px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        .modal-header {
            background: var(--warning);
            color: white;
            padding: 20px 25px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .modal-header.error {
            background: var(--error);
        }
        .modal-header h2 {
            font-size: 20px;
            font-weight: 600;
        }
        .modal-body {
            padding: 25px;
            max-height: 50vh;
            overflow-y: auto;
        }
        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        .btn-secondary {
            background: white;
            color: var(--hks-dark);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover {
            background: var(--hks-light);
        }
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        .btn-warning:hover {
            background: #f57c00;
        }
        
        /* Mismatch table */
        .mismatch-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .mismatch-table th,
        .mismatch-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .mismatch-table th {
            background: var(--hks-light);
            font-weight: 600;
            font-size: 13px;
            color: var(--hks-grey);
        }
        .mismatch-table td {
            font-size: 14px;
        }
        .mismatch-original {
            font-family: monospace;
            background: #fff3e0;
            padding: 4px 8px;
            border-radius: 4px;
            color: #e65100;
        }
        .mismatch-arrow {
            color: var(--hks-grey);
            font-size: 18px;
        }
        .mismatch-suggestion {
            font-family: monospace;
            background: #e8f5e9;
            padding: 4px 8px;
            border-radius: 4px;
            color: #2e7d32;
        }
        .match-percent {
            font-size: 12px;
            color: #666;
            margin-left: 8px;
        }
        
        /* Mapping select dropdown */
        .mapping-select {
            padding: 8px 12px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            min-width: 160px;
            background: white;
            cursor: pointer;
        }
        .mapping-select:focus {
            outline: none;
            border-color: var(--accent);
        }
        .custom-input {
            padding: 8px 12px;
            border: 2px solid var(--accent);
            border-radius: 6px;
            font-size: 14px;
            width: 140px;
            margin-left: 8px;
        }
        .revit-note {
            background: #fff8e1;
            border: 1px solid #ffcc02;
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .revit-note strong {
            color: #f57c00;
        }
        
        /* Collapsible sections */
        .collapsible-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin-bottom: 20px;
        }
        .collapsible-section {
            border: 1px solid var(--border);
            border-radius: 8px;
            overflow: hidden;
            flex: 1;
            min-width: 200px;
            transition: flex-basis 0.3s ease;
        }
        .collapsible-section.expanded {
            flex-basis: 100%;
        }
        .collapsible-header {
            background: #f5f5f5;
            padding: 12px 15px;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: var(--hks-grey);
            user-select: none;
            border-radius: 8px;
        }
        .collapsible-section.expanded .collapsible-header {
            border-radius: 8px 8px 0 0;
        }
        .collapsible-header:hover {
            background: #ebebeb;
        }
        .collapsible-icon {
            font-size: 12px;
            transition: transform 0.3s ease;
        }
        .collapsible-section.expanded .collapsible-icon {
            transform: rotate(180deg);
        }
        .collapsible-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
            background: white;
            border-radius: 0 0 8px 8px;
        }
        .collapsible-section.expanded .collapsible-content {
            max-height: 5000px;
            overflow: hidden;
        }
        .collapsible-inner {
            padding: 15px;
            font-size: 14px;
            line-height: 1.6;
        }
        .collapsible-inner h4 {
            color: var(--hks-grey);
            margin: 20px 0 10px 0;
            font-size: 15px;
        }
        .collapsible-inner h4:first-child {
            margin-top: 0;
        }
        .collapsible-inner ul {
            margin: 10px 0;
            padding-left: 20px;
        }
        .collapsible-inner li {
            margin: 6px 0;
        }
        .collapsible-inner p {
            margin: 10px 0;
        }
        
        /* Info table */
        .info-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
            font-size: 13px;
        }
        .info-table th {
            background: var(--hks-grey);
            color: white;
            padding: 8px 12px;
            text-align: left;
            font-weight: 600;
        }
        .info-table td {
            padding: 8px 12px;
            border-bottom: 1px solid #eee;
        }
        .info-table tr:nth-child(even) {
            background: #f9f9f9;
        }
        .info-table code {
            background: #e8f5e9;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
            color: #2e7d32;
        }
        
        /* Tooltips */
        .tooltip-container {
            position: relative;
            display: inline-block;
        }
        .tooltip-icon {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 16px;
            height: 16px;
            background: var(--accent);
            color: white;
            border-radius: 50%;
            font-size: 11px;
            font-weight: bold;
            cursor: help;
            margin-left: 5px;
            vertical-align: middle;
        }
        .tooltip-text {
            visibility: hidden;
            opacity: 0;
            position: absolute;
            z-index: 100;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            font-weight: normal;
            width: 250px;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 8px;
            transition: opacity 0.2s ease;
            line-height: 1.4;
        }
        .tooltip-text::after {
            content: "";
            position: absolute;
            bottom: 100%;
            left: 50%;
            margin-left: -5px;
            border-width: 5px;
            border-style: solid;
            border-color: transparent transparent #333 transparent;
        }
        .tooltip-container:hover .tooltip-text,
        .tooltip-container:focus .tooltip-text {
            visibility: visible;
            opacity: 1;
        }
        
        /* Instruction images */
        .instruction-image {
            max-width: 100%;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin: 10px 0;
        }
        .image-placeholder {
            background: #f0f0f0;
            border: 2px dashed #ccc;
            border-radius: 6px;
            padding: 30px;
            text-align: center;
            color: #999;
            margin: 10px 0;
        }
        
        /* Step numbers in instructions */
        .instruction-step {
            display: flex;
            align-items: flex-start;
            margin: 10px 0;
        }
        .instruction-step-num {
            background: #b71c1c;
            color: white;
            width: 22px;
            height: 22px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
        }
        
        /* Note boxes */
        .note-box {
            background: #e3f2fd;
            border-left: 4px solid var(--accent);
            padding: 10px 15px;
            margin: 15px 0;
            font-size: 13px;
            border-radius: 0 6px 6px 0;
        }
        .note-box.warning {
            background: #fff8e1;
            border-left-color: #ff9800;
        }
        .note-box.success {
            background: #e8f5e9;
            border-left-color: #4caf50;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/HKS-Logo-White_N2.png" alt="HKS" style="height: 0.82em; vertical-align: -0.05em; margin-right: 10px;">BOMA Tabulator</h1>
            <p id="headerSubtitle">This tool converts Revit area exports to a HKS Formatted BOMA spreadsheet.</p>
        </div>
        
        <div class="content">
            <!-- Step 1: Upload -->
            <div class="step">
                
                <!-- Collapsible Help Sections -->
                <div class="collapsible-row" id="collapsibleHelpSections">
                
                <!-- Collapsible: Understanding BOMA Basics -->
                <div class="collapsible-section" id="bomaBasicsSection">
                    <div class="collapsible-header" onclick="toggleCollapsible('bomaBasicsSection')">
                        <span>üìò Understanding BOMA Basics</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <h4>What is BOMA?</h4>
                            <p>BOMA (Building Owners and Managers Association) provides a standardized method for measuring floor area in commercial buildings. The 2024 standard allows measurements within 2% accuracy.</p>
                            <p style="font-size: 13px;"><a href="https://hksinc.sharepoint.com/sites/trg/SitePages/MadCAD.aspx" target="_blank" style="color: var(--accent);">üìñ Access the official BOMA 2024 standard on MadCAD</a></p>
                            
                            <h4>Key Concepts</h4>
                            <ul>
                                <li><strong>Rentable SF</strong> = Gross Area ‚àí Floor Penetrations (holes in the floor)</li>
                                <li><strong>Efficiency %</strong> = Ratio of Rentable to Gross Area</li>
                                <li><strong>Load Factor</strong> = Your share of building common areas (amenities, corridors, etc.)</li>
                            </ul>
                            
                            <h4>Method A vs Method B</h4>
                            <ul>
                                <li><strong>Method B (Recommended):</strong> Simpler calculation, suitable for most projects</li>
                                <li><strong>Method A (Legacy):</strong> More complex, granular allocation used in older versions of BOMA</li>
                            </ul>
                            
                            <h4>Tips for Special Cases</h4>
                            <ul>
                                <li><strong>Retail spaces:</strong> Ask the developer how to handle‚Äîretailers typically don't want add-on factors. Consider pulling retail out as a separate number.</li>
                                <li><strong>Balconies:</strong> Rentable area but without load factor applied. (This is as of BOMA 2024)</li>
                                <li><strong>Parking (& Storage), & MVP:</strong> Excluded from load calculations</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                <!-- Collapsible: Setting up Revit Area Plans -->
                <div class="collapsible-section" id="revitAreaPlansSection">
                    <div class="collapsible-header" onclick="toggleCollapsible('revitAreaPlansSection')">
                        <span>üìê Setting up Revit Area Plans</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <h4>Measurement Guidelines within Revit</h4>
                            <ul>
                                <li>Measure to <strong>inside face of glass</strong> at exterior walls</li>
                                <li>For solid walls: measure to inside face of the <strong>dominant portion</strong> (from 8' down)</li>
                                <li>Group area boundary lines in Revit to avoid accidentally moving walls</li>
                                <li>Label charts as <strong>"Preliminary"</strong> and <strong>"Modified"</strong> as appropriate</li>
                            </ul>
                            
                            <h4>Area Type Categories ("Buckets")</h4>
                            <div class="note-box">
                                <strong>‚ìò Note:</strong> These abbreviations differ slightly from the official BOMA standard to help users and clients better understand the categories.
                            </div>
                            <table class="info-table">
                                <thead>
                                    <tr>
                                        <th>Abbrev</th>
                                        <th>Full Name</th>
                                        <th>What's Included</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr><td><code>TA</code></td><td>Tenant Area</td><td>Leasable space on each floor</td></tr>
                                    <tr><td><code>TA-BALC</code></td><td>Tenant Balcony</td><td>Exterior balconies (rentable but no load factor applied)</td></tr>
                                    <tr><td><code>PA</code></td><td>Parking Area</td><td>Parking and storage areas (excluded from load calculations)</td></tr>
                                    <tr><td><code>MVP</code></td><td>Major Vertical Penetration</td><td>Stairs, elevators, shafts (includes shaft walls)</td></tr>
                                    <tr><td><code>BSA</code></td><td>Building Service Area</td><td>Lobbies, fitness centers, lounges, building-wide mechanical</td></tr>
                                    <tr><td><code>BSA-DECK</code></td><td>Building Service Deck</td><td>Exterior amenity decks</td></tr>
                                    <tr><td><code>FSA</code></td><td>Floor Service Area</td><td>Restrooms, telecom closets, mechanical rooms serving each floor</td></tr>
                                    <tr><td><code>BBC</code></td><td>Base Building Circulation</td><td>Common corridors on multi-tenant floors</td></tr>
                                </tbody>
                            </table>
                            
                            <h4>Wall Priority Diagrams</h4>
                            <p>When drawing area boundaries in Revit, use the wall priority order shown below. Each diagram shows which area type "wins" when boundaries meet at a wall.</p>
                            <img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/boma-wall-priority-diagrams.gif" alt="BOMA Wall Priority Diagrams" class="instruction-image" style="max-width: 100%; border: 1px solid #ddd; border-radius: 6px;">
                        </div>
                    </div>
                </div>
                
                <!-- Collapsible: Exporting from Revit -->
                <div class="collapsible-section" id="revitExportSection">
                    <div class="collapsible-header" onclick="toggleCollapsible('revitExportSection')">
                        <span>üì§ Exporting from Revit</span>
                        <span class="collapsible-icon">‚ñº</span>
                    </div>
                    <div class="collapsible-content">
                        <div class="collapsible-inner">
                            <h4>Prerequisites</h4>
                            <p>Before exporting, ensure you have:</p>
                            <ul>
                                <li>Area boundaries drawn per BOMA standards (see "Setting up Revit Area Plans" above)</li>
                                <li>Each area assigned an abbreviation per HKS methods (TA, MVP, BSA, etc.)</li>
                                <li>A BOMA Area Scheme set up in Revit</li>
                            </ul>
                            
                            <h4>Step 1: Verify Your Area Scheme
                                <span class="tooltip-container">
                                    <span class="tooltip-icon">i</span>
                                    <span class="tooltip-text">Name your scheme descriptively, e.g., "BOMA 2024 - Office"</span>
                                </span>
                            </h4>
                            <div class="instruction-step">
                                <span class="instruction-step-num">1</span>
                                <span>Go to <strong>Room & Area</strong> dropdown</span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">2</span>
                                <span>Select <strong>Area and Volume Computations</strong></span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">3</span>
                                <span>Confirm your BOMA area scheme exists (or click <strong>New</strong> to create one)</span>
                            </div>
                            <img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/revit-step1-area-scheme.png" alt="Area and Volume Computations dialog" class="instruction-image">
                            
                            <h4>Step 2: Open Spreadsheet Link
                                <span class="tooltip-container">
                                    <span class="tooltip-icon">i</span>
                                    <span class="tooltip-text">This is a CTC BIM Project Suite tool. If you don't see it, contact your BIM manager.</span>
                                </span>
                            </h4>
                            <div class="instruction-step">
                                <span class="instruction-step-num">1</span>
                                <span>Click the <strong>Express Tools</strong> tab</span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">2</span>
                                <span>Click <strong>Spreadsheet Link</strong> (green "SL" icon)</span>
                            </div>
                            <img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/revit-step2-express-tools.png" alt="Express Tools ribbon with Spreadsheet Link" class="instruction-image">
                            
                            <h4>Step 3: Configure Export Settings
                                <span class="tooltip-container">
                                    <span class="tooltip-icon">i</span>
                                    <span class="tooltip-text">Next time you export, use "Load Settings ‚Üí From Project" to skip this setup.</span>
                                </span>
                            </h4>
                            <div class="instruction-step">
                                <span class="instruction-step-num">1</span>
                                <span>In the Settings dialog, select <strong>Areas</strong> from Available Categories</span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">2</span>
                                <span>Check <strong>"Hide unit symbol"</strong></span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">3</span>
                                <span>From Available Parameters, add in order: <strong>Level</strong>, <strong>Name</strong>, <strong>Area</strong></span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">4</span>
                                <span>Click <strong>Save Settings ‚Üí To Project</strong> (for easy re-export later)</span>
                            </div>
                            <img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/revit-step3-settings.png" alt="Spreadsheet Link Settings dialog" class="instruction-image">
                            
                            <h4>Step 4: Export and Save
                                <span class="tooltip-container">
                                    <span class="tooltip-icon">i</span>
                                    <span class="tooltip-text">Re-saving in Excel prevents compatibility errors when importing to the BOMA Tabulator.</span>
                                </span>
                            </h4>
                            <div class="instruction-step">
                                <span class="instruction-step-num">1</span>
                                <span>Click <strong>Save</strong> in the Spreadsheet Link window</span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">2</span>
                                <span>Choose a location and filename</span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">3</span>
                                <span>When prompted, click <strong>Yes</strong> to open in Excel</span>
                            </div>
                            <div class="instruction-step">
                                <span class="instruction-step-num">4</span>
                                <span><strong>Important:</strong> Save the file again as .xlsx in Excel before closing</span>
                            </div>
                            <img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/revit-step4-export.png" alt="Spreadsheet Link export preview" class="instruction-image">
                            
                            <h4>What to Expect</h4>
                            <p>Your exported file will have columns for Level, Name, and Area. You may see:</p>
                            <ul>
                                <li>An <strong>(Instance)</strong> row near the top‚Äîthis is normal and will be filtered out automatically</li>
                                <li>A blank row‚Äîalso filtered out automatically</li>
                            </ul>
                        </div>
                    </div>
                </div>
                
                </div><!-- End collapsible-row -->
                
                <!-- Step 1 Header -->
                <div class="step-header">
                    <div class="step-number">1</div>
                    <div class="step-title">Upload Revit Export</div>
                </div>
                
                <!-- Workflow Steps Summary -->
                <div id="workflowSteps" style="background: #f5f5f5; border: 1px solid var(--border); border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <div style="font-size: 14px; line-height: 1.8;">
                        <strong>Step 1:</strong> Upload your Revit export file<br>
                        <strong>Step 2:</strong> Enter project information<br>
                        <strong>Step 3:</strong> Map area types to BOMA categories<br>
                        <strong>Step 4:</strong> Review and select area types<br>
                        <strong>Step 5:</strong> Map and reorder building floors<br>
                        <strong>Step 6:</strong> Generate your BOMA spreadsheet
                    </div>
                </div>
                
                <!-- Upload Zone -->
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Click to browse or drag and drop</div>
                    <div class="upload-hint" style="font-size: 14px; color: #666;">Excel (.xlsx, .xls) or CSV</div>
                </div>
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv">
                <div class="file-info" id="fileInfo">
                    <span style="font-size: 32px; color: var(--success);">‚úì</span>
                    <div>
                        <h3 id="fileName" style="font-size: 16px; margin-bottom: 4px;"></h3>
                        <p id="fileDetails" style="font-size: 14px; color: #666;"></p>
                    </div>
                </div>
            </div>
            
            <!-- Step 2: Project Info -->
            <div class="step hidden" id="step2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <div class="step-title">Project Information</div>
                </div>
                <div class="info-box">
                    <p><strong>Optional:</strong> Enter project details below. Leave blank to use default values.</p>
                </div>
                <div class="project-info-grid">
                    <div class="project-field">
                        <label for="projectName">Project Name</label>
                        <input type="text" id="projectName" placeholder="Project Name">
                        <span class="hint">Default: "Project Name"</span>
                    </div>
                    <div class="project-field">
                        <label for="projectLocation">Location</label>
                        <input type="text" id="projectLocation" placeholder="City, State">
                        <span class="hint">Default: "City, State"</span>
                    </div>
                    <div class="project-field">
                        <label for="projectNumber">Project Number</label>
                        <input type="text" id="projectNumber" placeholder="00000.000">
                        <span class="hint">Default: "00000.000"</span>
                    </div>
                </div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn btn-primary" onclick="proceedToStep3()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 3: Map Area Types -->
            <div class="step hidden" id="step3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <div class="step-title">Map Area Types</div>
                </div>
                <div class="info-box">
                    <p><strong>Map:</strong> Match your Revit area type names to BOMA categories. Types already matching are shown as confirmed.</p>
                </div>
                
                <!-- Already Matched Types -->
                <div class="area-category" id="matchedTypesSection" style="display: none;">
                    <div class="area-category-header standard">
                        <span>‚úì Already Matched</span>
                    </div>
                    <div id="matchedTypesList" style="padding: 10px 15px; background: white;"></div>
                </div>
                
                <!-- Types Needing Mapping -->
                <div class="area-category" id="unmatchedTypesSection" style="display: none;">
                    <div class="area-category-header nonstandard">
                        <span>‚ö† Needs Mapping</span>
                    </div>
                    <div id="unmatchedTypesList" style="padding: 10px 15px; background: white;"></div>
                </div>
                
                <div id="allMatchedMessage" style="display: none; text-align: center; padding: 40px; background: #e8f5e9; border-radius: 8px; margin: 20px 0;">
                    <div style="font-size: 48px; margin-bottom: 10px;">‚úì</div>
                    <div style="font-size: 18px; font-weight: 600; color: #2e7d32;">All area types match BOMA standards!</div>
                    <div style="font-size: 14px; color: #666; margin-top: 5px;">No mapping needed. Click Continue to proceed.</div>
                </div>
                
                <div style="margin-top: 15px; text-align: right;">
                    <button class="btn" style="background: var(--hks-grey); color: white; margin-right: 10px;" onclick="showStep(2)">
                        ‚Üê Back
                    </button>
                    <button class="btn btn-primary" onclick="applyAreaTypeMappingsAndContinue()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 4: Area Type Review -->
            <div class="step hidden" id="step4">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <div class="step-title">Select Area Types</div>
                </div>
                <div class="info-box">
                    <p><strong>Select:</strong> Choose which area types to include in the calculations. BOMA types are pre-selected.</p>
                </div>
                
                <!-- BOMA Standard Types -->
                <div class="area-category" id="bomaStandardSection">
                    <div class="area-category-header standard">
                        <span>‚úì BOMA Standard Area Types</span>
                        <div class="area-category-actions">
                            <button onclick="selectAllStandard()">Select All</button>
                            <button onclick="deselectAllStandard()">Deselect All</button>
                        </div>
                    </div>
                    <div class="area-type-grid" id="standardAreaTypes"></div>
                </div>
                
                <!-- Non-Standard Types -->
                <div class="area-category" id="nonStandardSection">
                    <div class="area-category-header nonstandard">
                        <span>‚ö† Non-Standard Area Types</span>
                        <div class="area-category-actions">
                            <button onclick="selectAllNonStandard()">Select All</button>
                            <button onclick="deselectAllNonStandard()">Deselect All</button>
                        </div>
                    </div>
                    <div class="area-type-grid" id="nonStandardAreaTypes"></div>
                    <p class="nonstandard-note">These types are not recognized BOMA categories and are excluded by default. Select any you wish to include.</p>
                </div>
                
                <div style="margin-top: 15px; text-align: right;">
                    <button class="btn" style="background: var(--hks-grey); color: white; margin-right: 10px;" onclick="showStep(3)">
                        ‚Üê Back
                    </button>
                    <button class="btn btn-primary" onclick="proceedToStep5()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 5: Map Floors -->
            <div class="step hidden" id="step5">
                <div class="step-header">
                    <div class="step-number">5</div>
                    <div class="step-title">Map Building Floors</div>
                </div>
                <div class="info-box">
                    <p><strong>Instructions:</strong> Floors auto-sorted (Roof ‚Üí Floors ‚Üí Ground ‚Üí Basements). <strong>Drag-and-drop</strong> to reorder, or add/remove floors as needed.</p>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalLevels">0</div>
                        <div class="stat-label">REVIT LEVELS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalRows">0</div>
                        <div class="stat-label">DATA ROWS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalFloors">0</div>
                        <div class="stat-label">MAPPED FLOORS</div>
                    </div>
                </div>
                <div style="margin-bottom: 6px;">
                    <button class="btn" style="background: var(--hks-grey); color: white; padding: 6px 12px; font-size: 12px;" onclick="autoSortFloors()">
                        <span>‚áÖ</span> Auto-Sort
                    </button>
                    <button class="btn" style="background: white; color: var(--hks-dark); border: 1px solid var(--border); padding: 6px 12px; font-size: 12px;" onclick="resetMappings()">
                        <span>‚Ü∫</span> Reset
                    </button>
                </div>
                <div class="mapping-container" id="mappingContainer"></div>
                <div style="margin-top: 8px; text-align: right;">
                    <button class="btn" style="background: var(--hks-grey); color: white; margin-right: 10px;" onclick="showStep(4)">
                        ‚Üê Back
                    </button>
                    <button class="btn btn-primary" onclick="proceedToGenerate()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 6: Generate -->
            <div class="step hidden" id="step6">
                <div class="step-header">
                    <div class="step-number">6</div>
                    <div class="step-title">Generate BOMA Spreadsheet</div>
                </div>
                <div class="info-box" style="background: #fff3e0; border-left-color: var(--warning);">
                    <p><strong>Ready:</strong> Excel file will include BOMA Method A & B calculations with formulas, plus your Revit data (with typical floor duplications).</p>
                </div>
                <button class="btn btn-success" id="generateBtn" onclick="generateExcel()">
                    <span>üìä</span> Generate Excel with Formulas
                </button>
                <div style="margin-top: 20px;">
                    <button class="btn" style="background: var(--hks-grey); color: white;" onclick="showStep(5)">
                        ‚Üê Back
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let workbookData = null;
        let rawData = [];
        let revitLevels = [];
        let floorMappings = [];
        let levelColumn = null;
        let originalMappings = [];
        let draggedIndex = null;
        let areaTypes = [];
        let selectedAreaTypes = [];
        let areaTypeMappings = {}; // Maps user's area types to BOMA categories
        let areaTypeMappingSelections = {}; // Selections from Step 3 mapping UI
        
        // Expected BOMA area types
        const EXPECTED_AREA_TYPES = ['TA', 'TA-BALC', 'MVP', 'PA', 'BSA', 'BSA-DECK', 'FSA', 'BBC'];
        
        // Levenshtein distance for fuzzy matching
        function levenshteinDistance(a, b) {
            const matrix = [];
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }
        
        // Calculate similarity percentage
        function getSimilarity(str1, str2) {
            const s1 = str1.toUpperCase().replace(/\s+/g, '');
            const s2 = str2.toUpperCase().replace(/\s+/g, '');
            const maxLen = Math.max(s1.length, s2.length);
            if (maxLen === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return Math.round((1 - distance / maxLen) * 100);
        }
        
        // Find best matching expected type
        function findBestMatch(userType) {
            let bestMatch = null;
            let bestScore = 0;
            
            // Normalize for comparison
            const normalized = userType.toUpperCase().replace(/\s+/g, '').replace(/-+/g, '-');
            
            // Check for exact match first
            for (const expected of EXPECTED_AREA_TYPES) {
                if (normalized === expected) {
                    return { match: expected, score: 100 };
                }
            }
            
            // Fuzzy match
            for (const expected of EXPECTED_AREA_TYPES) {
                const score = getSimilarity(userType, expected);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = expected;
                }
            }
            
            return { match: bestMatch, score: bestScore };
        }
        
        // DOM elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const mappingContainer = document.getElementById('mappingContainer');
        
        // Upload handlers
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.style.borderColor = 'var(--accent)'; });
        uploadZone.addEventListener('dragleave', () => uploadZone.style.borderColor = '');
        uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            uploadZone.style.borderColor = '';
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', e => { if (e.target.files[0]) handleFile(e.target.files[0]); });
        
        function handleFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['xlsx', 'xls', 'csv'].includes(ext)) {
                alert('Please upload Excel or CSV file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    workbookData = workbook;
                    
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { defval: '' });
                    
                    if (jsonData.length === 0) {
                        alert('File is empty');
                        return;
                    }
                    
                    // Filter out (Instance) rows and blank rows that come from Revit exports
                    const nameCol = Object.keys(jsonData[0]).find(k => k.toLowerCase() === 'name');
                    const filteredData = jsonData.filter(row => {
                        // Check Name column for (Instance) or blank
                        if (nameCol) {
                            const name = row[nameCol];
                            if (!name || (typeof name === 'string' && (name.trim() === '' || name.includes('(Instance)')))) {
                                return false;
                            }
                        }
                        return true;
                    });
                    
                    rawData = filteredData;
                    levelColumn = Object.keys(filteredData[0] || jsonData[0]).find(k => k.toLowerCase().includes('level'));
                    
                    if (!levelColumn) {
                        alert('No "Level" column found');
                        return;
                    }
                    
                    // Extract levels (allow short names like "P3")
                    revitLevels = [];
                    const seen = {};
                    filteredData.forEach(row => {
                        const level = row[levelColumn];
                        if (level && typeof level === 'string' && level.trim().length > 0 && !seen[level]) {
                            seen[level] = true;
                            revitLevels.push(level);
                        }
                    });
                    
                    if (revitLevels.length === 0) {
                        alert('No valid levels found');
                        return;
                    }
                    
                    // Extract area types
                    if (nameCol) {
                        const typeSet = new Set();
                        filteredData.forEach(row => {
                            const name = row[nameCol];
                            if (name && typeof name === 'string' && name.trim().length > 0) {
                                typeSet.add(name.trim());
                            }
                        });
                        areaTypes = Array.from(typeSet).sort();
                        // selectedAreaTypes will be set by renderAreaTypes/categorizeAreaTypes
                    }
                    
                    document.getElementById('fileName').textContent = file.name;
                    document.getElementById('fileDetails').textContent = `${revitLevels.length} levels ‚Ä¢ ${filteredData.length} rows ‚Ä¢ ${areaTypes.length} area types`;
                    document.getElementById('fileInfo').classList.add('active');
                    document.getElementById('totalLevels').textContent = revitLevels.length;
                    document.getElementById('totalRows').textContent = filteredData.length;
                    
                    initializeFloorMappings();
                    renderAreaTypes();
                    
                    // Clear any old mappings and proceed to step 2
                    areaTypeMappings = {};
                    showStep(2);
                } catch (error) {
                    alert('Error: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Area Type Functions
        // Check if an area type matches BOMA standards (exact or normalized match)
        function isBomaStandard(type) {
            const upperType = type.toUpperCase();
            // Check exact match first
            if (EXPECTED_AREA_TYPES.some(exp => exp.toUpperCase() === upperType)) {
                return true;
            }
            // Check normalized match (removing spaces)
            const normalized = upperType.replace(/\s+/g, '').replace(/-+/g, '-');
            return EXPECTED_AREA_TYPES.some(exp => exp.toUpperCase() === normalized);
        }
        
        // Categorize area types into standard and non-standard
        let standardTypes = [];
        let nonStandardTypes = [];
        
        function categorizeAreaTypes() {
            standardTypes = [];
            nonStandardTypes = [];
            
            areaTypes.forEach(type => {
                // Check if this type was mapped in Step 3
                const mappedTo = areaTypeMappingSelections[type];
                
                // Skip types mapped to NONE - they are excluded from output entirely
                if (mappedTo === 'NONE') {
                    return;
                }
                
                if (mappedTo && mappedTo !== 'NON-BOMA' && EXPECTED_AREA_TYPES.some(exp => exp.toUpperCase() === mappedTo.toUpperCase())) {
                    // Type was mapped to a BOMA standard type
                    standardTypes.push(type);
                } else if (mappedTo === 'NON-BOMA') {
                    // Type was explicitly mapped to NON-BOMA
                    nonStandardTypes.push(type);
                } else if (isBomaStandard(type)) {
                    // Type matches BOMA standard directly
                    standardTypes.push(type);
                } else {
                    // Default to non-standard
                    nonStandardTypes.push(type);
                }
            });
            
            // Pre-select only standard types
            selectedAreaTypes = [...standardTypes];
        }
        
        function renderAreaTypes() {
            categorizeAreaTypes();
            
            const standardGrid = document.getElementById('standardAreaTypes');
            const nonStandardGrid = document.getElementById('nonStandardAreaTypes');
            const standardSection = document.getElementById('bomaStandardSection');
            const nonStandardSection = document.getElementById('nonStandardSection');
            
            // Render standard types
            standardGrid.innerHTML = '';
            if (standardTypes.length === 0) {
                standardGrid.innerHTML = '<p style="color: #666; font-size: 13px; margin: 5px 0;">No BOMA standard area types found in your data.</p>';
            } else {
                standardTypes.forEach(type => {
                    const div = document.createElement('div');
                    div.className = 'area-type-item';
                    const isChecked = selectedAreaTypes.includes(type);
                    const safeId = type.replace(/[^a-zA-Z0-9]/g, '_');
                    const mappedTo = areaTypeMappingSelections[type];
                    const isMapped = mappedTo && mappedTo !== type && mappedTo !== 'NON-BOMA';
                    const displayLabel = isMapped ? `${type} <span style="color: #2e7d32; font-size: 11px;">‚Üí ${mappedTo}</span>` : type;
                    div.innerHTML = `
                        <input type="checkbox" id="at_${safeId}" ${isChecked ? 'checked' : ''} 
                               onchange="toggleAreaType('${type.replace(/'/g, "\\'")}', this.checked)">
                        <label for="at_${safeId}">${displayLabel}</label>
                    `;
                    standardGrid.appendChild(div);
                });
            }
            
            // Render non-standard types
            nonStandardGrid.innerHTML = '';
            if (nonStandardTypes.length === 0) {
                nonStandardSection.style.display = 'none';
            } else {
                nonStandardSection.style.display = 'block';
                nonStandardTypes.forEach(type => {
                    const div = document.createElement('div');
                    div.className = 'area-type-item';
                    const isChecked = selectedAreaTypes.includes(type);
                    const safeId = type.replace(/[^a-zA-Z0-9]/g, '_');
                    div.innerHTML = `
                        <input type="checkbox" id="at_${safeId}" ${isChecked ? 'checked' : ''} 
                               onchange="toggleAreaType('${type.replace(/'/g, "\\'")}', this.checked)">
                        <label for="at_${safeId}">${type}</label>
                    `;
                    nonStandardGrid.appendChild(div);
                });
            }
        }
        
        function toggleAreaType(type, checked) {
            if (checked && !selectedAreaTypes.includes(type)) {
                selectedAreaTypes.push(type);
            } else if (!checked) {
                selectedAreaTypes = selectedAreaTypes.filter(t => t !== type);
            }
        }
        
        function selectAllStandard() {
            standardTypes.forEach(type => {
                if (!selectedAreaTypes.includes(type)) {
                    selectedAreaTypes.push(type);
                }
            });
            updateAreaTypeCheckboxes();
        }
        
        function deselectAllStandard() {
            selectedAreaTypes = selectedAreaTypes.filter(t => !standardTypes.includes(t));
            updateAreaTypeCheckboxes();
        }
        
        function selectAllNonStandard() {
            nonStandardTypes.forEach(type => {
                if (!selectedAreaTypes.includes(type)) {
                    selectedAreaTypes.push(type);
                }
            });
            updateAreaTypeCheckboxes();
        }
        
        function deselectAllNonStandard() {
            selectedAreaTypes = selectedAreaTypes.filter(t => !nonStandardTypes.includes(t));
            updateAreaTypeCheckboxes();
        }
        
        function updateAreaTypeCheckboxes() {
            areaTypes.forEach(type => {
                const safeId = type.replace(/[^a-zA-Z0-9]/g, '_');
                const checkbox = document.getElementById(`at_${safeId}`);
                if (checkbox) {
                    checkbox.checked = selectedAreaTypes.includes(type);
                }
            });
        }
        
        // Keep old functions for compatibility
        function selectAllAreaTypes() {
            selectedAreaTypes = [...areaTypes];
            updateAreaTypeCheckboxes();
        }
        
        function deselectAllAreaTypes() {
            selectedAreaTypes = [];
            updateAreaTypeCheckboxes();
        }
        
        function initializeFloorMappings() {
            floorMappings = revitLevels.map(level => ({
                revitLevel: level,
                buildingFloor: level,
                isNew: false
            }));
            
            // Auto-sort on load
            floorMappings.sort((a, b) => compareFloors(a.buildingFloor, b.buildingFloor));
            originalMappings = JSON.parse(JSON.stringify(floorMappings));
            renderFloorMappings();
        }
        
        function compareFloors(f1, f2) {
            const info1 = analyzeFloor(f1);
            const info2 = analyzeFloor(f2);
            if (info1.category !== info2.category) return info1.category - info2.category;
            if (info1.category === 3) return info2.number - info1.number; // Regular floors: high to low
            return info1.number - info2.number; // Basements: B1, B2, B3...
        }
        
        function analyzeFloor(name) {
            const n = name.toUpperCase();
            if (n.includes('ROOF')) return { category: 0, number: 0 };
            if (n.includes('PENTHOUSE') || n.includes('MECHANICAL') || n.includes('MACHINE') || n.includes('PH'))
                return { category: 1, number: 0 };
            if (n.includes('GROUND') || n.includes('LOBBY') || n.includes('MAIN') || n === 'G' || n === 'L')
                return { category: 4, number: 0 };
            
            const bMatch = n.match(/B[-\s]?(\d+)/i);
            if (bMatch) return { category: 5, number: parseInt(bMatch[1]) };
            
            const fMatch = n.match(/(?:LEVEL|L|P|FLOOR)[-\s]?(\d+)/i) || n.match(/^(\d+)/);
            if (fMatch) return { category: 3, number: parseInt(fMatch[1]) };
            
            return { category: 3, number: 0 };
        }
        
        function autoSortFloors() {
            floorMappings.sort((a, b) => compareFloors(a.buildingFloor, b.buildingFloor));
            renderFloorMappings();
        }
        
        function resetMappings() {
            if (confirm('Reset all changes?')) {
                floorMappings = JSON.parse(JSON.stringify(originalMappings));
                renderFloorMappings();
            }
        }
        
        function renderFloorMappings() {
            mappingContainer.innerHTML = '';
            floorMappings.forEach((m, i) => {
                const div = document.createElement('div');
                div.className = 'floor-item';
                div.draggable = true;
                div.dataset.index = i;
                
                // For new floors, show which level's data is being copied
                let labelText = m.revitLevel;
                let labelStyle = '';
                if (m.isNew) {
                    labelText = `Copy of ${m.sourceLevel || 'unknown'} Data`;
                    labelStyle = 'background: #e3f2fd; color: #1565c0;';
                }
                
                div.innerHTML = `
                    <div class="drag-handle">‚ãÆ‚ãÆ</div>
                    <div class="floor-label" style="${labelStyle}">${labelText}</div>
                    <div style="color: var(--hks-grey);">‚Üí</div>
                    <input type="text" class="floor-input" value="${m.buildingFloor}"
                           onchange="updateFloorName(${i}, this.value)"
                           placeholder="Floor name">
                    <div class="floor-actions">
                        <button class="action-btn" onclick="addFloorAbove(${i})">+ Above</button>
                        <button class="action-btn" onclick="addFloorBelow(${i})">+ Below</button>
                        <button class="action-btn remove" onclick="removeFloor(${i})">‚úï</button>
                    </div>
                `;
                
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);
                
                mappingContainer.appendChild(div);
            });
            
            document.getElementById('totalFloors').textContent = floorMappings.length;
        }
        
        function handleDragStart(e) {
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            document.querySelectorAll('.floor-item').forEach(el => el.classList.remove('drag-over'));
            this.classList.add('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            const dropIndex = parseInt(this.dataset.index);
            if (draggedIndex !== null && draggedIndex !== dropIndex) {
                const item = floorMappings[draggedIndex];
                floorMappings.splice(draggedIndex, 1);
                floorMappings.splice(draggedIndex < dropIndex ? dropIndex - 1 : dropIndex, 0, item);
                renderFloorMappings();
            }
        }
        
        function handleDragEnd() {
            this.classList.remove('dragging');
            document.querySelectorAll('.floor-item').forEach(el => el.classList.remove('drag-over'));
            draggedIndex = null;
        }
        
        function updateFloorName(i, v) { floorMappings[i].buildingFloor = v.trim(); }
        
        function addFloorAbove(i) {
            const nextName = getNextFloorName(floorMappings[i].buildingFloor, 'above');
            // New floor inherits from the floor it was created from
            const sourceLevel = floorMappings[i].isNew ? floorMappings[i].sourceLevel : floorMappings[i].revitLevel;
            floorMappings.splice(i, 0, { 
                revitLevel: '(New)', 
                buildingFloor: nextName, 
                isNew: true,
                sourceLevel: sourceLevel
            });
            renderFloorMappings();
        }
        
        function addFloorBelow(i) {
            const nextName = getNextFloorName(floorMappings[i].buildingFloor, 'below');
            const sourceLevel = floorMappings[i].isNew ? floorMappings[i].sourceLevel : floorMappings[i].revitLevel;
            floorMappings.splice(i + 1, 0, { 
                revitLevel: '(New)', 
                buildingFloor: nextName, 
                isNew: true,
                sourceLevel: sourceLevel
            });
            renderFloorMappings();
        }
        
        function getNextFloorName(currentName, direction) {
            const num = currentName.match(/\d+/);
            if (!num) return currentName + ' (Copy)';
            
            const n = parseInt(num[0]);
            const digitCount = num[0].length;
            const prefix = currentName.substring(0, currentName.indexOf(num[0]));
            const suffix = currentName.substring(currentName.indexOf(num[0]) + num[0].length);
            
            const isBasement = currentName.toUpperCase().includes('B');
            let newNum;
            
            if (isBasement) {
                newNum = direction === 'above' ? n - 1 : n + 1;
            } else {
                newNum = direction === 'above' ? n + 1 : n - 1;
            }
            
            if (newNum <= 0) return currentName + ' (Copy)';
            
            // Preserve digit format (e.g., 06 stays 2 digits)
            let newNumStr = newNum.toString();
            if (newNumStr.length < digitCount) {
                newNumStr = newNumStr.padStart(digitCount, '0');
            }
            
            return prefix + newNumStr + suffix;
        }
        
        function removeFloor(i) {
            if (confirm('Remove this floor?')) {
                floorMappings.splice(i, 1);
                renderFloorMappings();
            }
        }
        
        // Toggle collapsible sections (accordion behavior - only one open at a time)
        function toggleCollapsible(sectionId) {
            const section = document.getElementById(sectionId);
            if (section) {
                const isExpanding = !section.classList.contains('expanded');
                
                // Collapse all sections in the same row
                if (isExpanding) {
                    document.querySelectorAll('.collapsible-row .collapsible-section.expanded').forEach(el => {
                        el.classList.remove('expanded');
                    });
                }
                
                section.classList.toggle('expanded');
            }
        }
        
        function showStep(n) {
            document.querySelectorAll('.step').forEach(el => el.classList.add('hidden'));
            const stepId = n === 2 ? 'step2' : n === 3 ? 'step3' : n === 4 ? 'step4' : n === 5 ? 'step5' : 'step6';
            document.getElementById(stepId).classList.remove('hidden');
            
            // Hide header subtitle, workflow steps, and collapsible sections after step 1
            const subtitle = document.getElementById('headerSubtitle');
            const steps = document.getElementById('workflowSteps');
            const collapsibleRow = document.getElementById('collapsibleHelpSections');
            if (subtitle) subtitle.style.display = 'none';
            if (steps) steps.style.display = 'none';
            if (collapsibleRow) collapsibleRow.style.display = 'none';
        }
        
        // Keyword mapping for smart suggestions
        const KEYWORD_MAPPINGS = {
            'TA': ['TENANT', 'OFFICE', 'LEASE'],
            'TA-BALC': ['TENANT BALC', 'TA BALC', 'TA-BALC', 'TA- BALC'],
            'PA': ['PARKING', 'PARK', 'GARAGE', 'STORAGE', 'STOR'],
            'MVP': ['SHAFT', 'STAIR', 'ELEVATOR', 'ELEV', 'VERTICAL', 'PENETRATION'],
            'BSA': ['LOBBY', 'FITNESS', 'LOUNGE', 'BUILDING SERVICE', 'AMENITY'],
            'BSA-DECK': ['BSA DECK', 'BSA-DECK', 'BSA- DECK', 'BUILDING DECK'],
            'FSA': ['RESTROOM', 'TOILET', 'TELECOM', 'DATA', 'FLOOR SERVICE', 'MECHANICAL'],
            'BBC': ['CORRIDOR', 'CIRCULATION', 'COMMON']
        };
        
        // Find best BOMA match using keywords
        function findKeywordMatch(typeName) {
            const upperName = typeName.toUpperCase();
            
            // First pass: check for specific compound keywords (more specific matches first)
            // This prevents "REST. BALC." from matching "TA-BALC"
            for (const [bomaType, keywords] of Object.entries(KEYWORD_MAPPINGS)) {
                for (const keyword of keywords) {
                    // For compound keywords (contain space or dash), require exact phrase
                    if ((keyword.includes(' ') || keyword.includes('-')) && upperName.includes(keyword.replace(/[\s-]+/g, ''))) {
                        // Normalize both for comparison (remove spaces/dashes)
                        const normalizedName = upperName.replace(/[\s.-]+/g, '');
                        const normalizedKeyword = keyword.replace(/[\s-]+/g, '');
                        if (normalizedName.includes(normalizedKeyword)) {
                            return bomaType;
                        }
                    }
                }
            }
            
            // Second pass: check single-word keywords
            for (const [bomaType, keywords] of Object.entries(KEYWORD_MAPPINGS)) {
                for (const keyword of keywords) {
                    if (!keyword.includes(' ') && !keyword.includes('-') && upperName.includes(keyword)) {
                        return bomaType;
                    }
                }
            }
            
            // Fall back to fuzzy match using Levenshtein
            const { match, score } = findBestMatch(typeName);
            if (score >= 50) {
                return match;
            }
            
            return 'NON-BOMA';
        }
        
        function proceedToStep3() {
            renderAreaTypeMappingUI();
            showStep(3);
        }
        
        function renderAreaTypeMappingUI() {
            const matchedList = document.getElementById('matchedTypesList');
            const unmatchedList = document.getElementById('unmatchedTypesList');
            const matchedSection = document.getElementById('matchedTypesSection');
            const unmatchedSection = document.getElementById('unmatchedTypesSection');
            const allMatchedMsg = document.getElementById('allMatchedMessage');
            
            const matched = [];
            const unmatched = [];
            
            // Categorize area types
            areaTypes.forEach(type => {
                const upperType = type.toUpperCase();
                const isExactMatch = EXPECTED_AREA_TYPES.some(exp => exp.toUpperCase() === upperType);
                
                if (isExactMatch) {
                    matched.push({ original: type, mappedTo: type });
                } else {
                    const suggestion = findKeywordMatch(type);
                    unmatched.push({ original: type, suggestion: suggestion });
                }
            });
            
            // Initialize mapping selections
            areaTypeMappingSelections = {};
            matched.forEach(m => { areaTypeMappingSelections[m.original] = m.mappedTo; });
            unmatched.forEach(u => { areaTypeMappingSelections[u.original] = u.suggestion; });
            
            // Render matched types
            if (matched.length > 0) {
                matchedSection.style.display = 'block';
                matchedList.innerHTML = matched.map(m => `
                    <div style="display: flex; align-items: center; padding: 8px 0; border-bottom: 1px solid #eee;">
                        <span style="min-width: 200px; font-weight: 500;">${m.original}</span>
                        <span style="color: #2e7d32;">‚úì Matched</span>
                    </div>
                `).join('');
            } else {
                matchedSection.style.display = 'none';
            }
            
            // Render unmatched types
            if (unmatched.length > 0) {
                unmatchedSection.style.display = 'block';
                allMatchedMsg.style.display = 'none';
                unmatchedList.innerHTML = unmatched.map(u => `
                    <div style="display: flex; align-items: center; padding: 10px 0; border-bottom: 1px solid #eee; gap: 15px;">
                        <span class="mismatch-original" style="min-width: 200px;">${u.original}</span>
                        <span style="color: var(--hks-grey);">‚Üí</span>
                        <select class="mapping-select" onchange="updateMappingSelection('${u.original.replace(/'/g, "\\'")}', this.value)">
                            <option value="TA" ${u.suggestion === 'TA' ? 'selected' : ''}>TA (Tenant Area)</option>
                            <option value="TA-BALC" ${u.suggestion === 'TA-BALC' ? 'selected' : ''}>TA-BALC (Tenant Balcony)</option>
                            <option value="PA" ${u.suggestion === 'PA' ? 'selected' : ''}>PA (Parking Area)</option>
                            <option value="MVP" ${u.suggestion === 'MVP' ? 'selected' : ''}>MVP (Major Vertical Penetration)</option>
                            <option value="BSA" ${u.suggestion === 'BSA' ? 'selected' : ''}>BSA (Building Service Area)</option>
                            <option value="BSA-DECK" ${u.suggestion === 'BSA-DECK' ? 'selected' : ''}>BSA-DECK (Building Service Deck)</option>
                            <option value="FSA" ${u.suggestion === 'FSA' ? 'selected' : ''}>FSA (Floor Service Area)</option>
                            <option value="BBC" ${u.suggestion === 'BBC' ? 'selected' : ''}>BBC (Base Building Circulation)</option>
                            <option value="NON-BOMA" ${u.suggestion === 'NON-BOMA' ? 'selected' : ''}>Non-BOMA Area</option>
                            <option value="NONE">None (Exclude from output)</option>
                        </select>
                    </div>
                `).join('');
            } else {
                unmatchedSection.style.display = 'none';
                allMatchedMsg.style.display = 'block';
            }
        }
        
        function updateMappingSelection(original, value) {
            areaTypeMappingSelections[original] = value;
        }
        
        function applyAreaTypeMappingsAndContinue() {
            // Apply the mappings to areaTypeMappings (used during Excel generation)
            areaTypeMappings = {};
            
            for (const [original, mapped] of Object.entries(areaTypeMappingSelections)) {
                if (mapped !== original && mapped !== 'NON-BOMA') {
                    areaTypeMappings[original] = mapped;
                }
            }
            
            // Update areaTypes with mapped values for categorization
            // This affects how renderAreaTypes categorizes them
            showStep(4);
            renderAreaTypes();
        }
        
        function proceedToStep5() {
            if (selectedAreaTypes.length === 0) {
                alert('Please select at least one area type');
                return;
            }
            showStep(5);
        }
        
        function proceedToGenerate() {
            const empty = floorMappings.filter(m => !m.buildingFloor.trim());
            if (empty.length > 0) {
                alert(`Please name all ${empty.length} floor(s)`);
                return;
            }
            showStep(6);
        }
        
        // Template URL - upload BOMA_Template.xlsx to GitHub for formatted output
        const TEMPLATE_URL = 'https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/BOMA_Template.xlsx';
        
        async function generateExcel() {
            const generateBtn = document.getElementById('generateBtn');
            try {
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<span class="spinner"></span> Generating...';
                
                // Get project info with defaults
                const projectInfo = {
                    name: document.getElementById('projectName').value.trim() || 'Project Name',
                    location: document.getElementById('projectLocation').value.trim() || 'City, State',
                    number: document.getElementById('projectNumber').value.trim() || '00000.000'
                };
                
                // Build mapping lookup and source floor lookup
                const mappingLookup = {};  // Revit level -> Building floor
                const sourceFloorLookup = {};  // Building floor -> Source Revit level
                
                floorMappings.forEach(m => {
                    if (!m.isNew) {
                        mappingLookup[m.revitLevel] = m.buildingFloor;
                        sourceFloorLookup[m.buildingFloor] = m.revitLevel;
                    } else {
                        // New floor - use its stored sourceLevel
                        sourceFloorLookup[m.buildingFloor] = m.sourceLevel || null;
                    }
                });
                
                // For new floors without explicit source, find from neighbors
                floorMappings.forEach((m, idx) => {
                    if (m.isNew && !sourceFloorLookup[m.buildingFloor]) {
                        let sourceFloor = null;
                        
                        // Search BELOW first
                        for (let i = idx + 1; i < floorMappings.length; i++) {
                            if (!floorMappings[i].isNew) {
                                sourceFloor = floorMappings[i].revitLevel;
                                break;
                            }
                        }
                        
                        // Then search ABOVE
                        if (!sourceFloor) {
                            for (let i = idx - 1; i >= 0; i--) {
                                if (!floorMappings[i].isNew) {
                                    sourceFloor = floorMappings[i].revitLevel;
                                    break;
                                }
                            }
                        }
                        
                        if (sourceFloor) {
                            sourceFloorLookup[m.buildingFloor] = sourceFloor;
                        }
                    }
                });
                
                // Get name column
                const nameCol = Object.keys(rawData[0]).find(k => k.toLowerCase() === 'name');
                
                // Create EXPANDED mapped data - includes duplicated rows for typical floors
                const mappedData = [];
                
                // For each floor in the building (including new/typical floors)
                floorMappings.forEach(floorMapping => {
                    const buildingFloor = floorMapping.buildingFloor;
                    const sourceLevel = sourceFloorLookup[buildingFloor];
                    
                    if (!sourceLevel) return;
                    
                    // Get all data rows for the source level
                    rawData.forEach(row => {
                        const level = row[levelColumn];
                        if (level !== sourceLevel) return;
                        
                        const areaType = nameCol ? row[nameCol] : '';
                        
                        // Filter by selected area types
                        if (nameCol && !selectedAreaTypes.includes(areaType)) return;
                        
                        // Add row with the building floor name (not source level)
                        // Apply area type mapping if exists
                        const mappedAreaType = areaTypeMappings[areaType] || areaType || '';
                        
                        mappedData.push({
                            FloorMap: buildingFloor,
                            Name: mappedAreaType,
                            OriginalName: areaType, // Keep original for NON-BOMA filtering
                            'Area Scheme Name': row['Area Scheme Name'] || 'BOMA 2024',
                            Area: parseFloat(row.Area) || 0
                        });
                    });
                });
                
                if (mappedData.length === 0) {
                    alert('No data to export. Check your area type selections.');
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
                    return;
                }
                
                // Get all floors from floorMappings
                const allFloors = floorMappings.map(m => m.buildingFloor);
                
                // Try template first, fall back to basic generation
                try {
                    await generateWithTemplate(allFloors, sourceFloorLookup, mappedData, projectInfo);
                    
                    // Build success message
                    const selectedNonStd = nonStandardTypes.filter(t => selectedAreaTypes.includes(t));
                    let successMsg = '‚úì BOMA Excel generated with formatting!\n\n' +
                          `‚Ä¢ HKS-BOMA-B - ${allFloors.length} floors\n` +
                          `‚Ä¢ HKS-BOMA-A - ${allFloors.length} floors\n`;
                    
                    if (selectedNonStd.length > 0) {
                        // Count floors that actually have non-BOMA data
                        const nonBomaFloorCount = allFloors.filter(floor => 
                            mappedData.some(row => 
                                row.FloorMap === floor && 
                                selectedNonStd.includes(row.Name) &&
                                row.Area > 0
                            )
                        ).length;
                        
                        if (nonBomaFloorCount > 0) {
                            successMsg += `‚Ä¢ NON-BOMA Areas - ${nonBomaFloorCount} floors √ó ${selectedNonStd.length} types\n`;
                        }
                    }
                    
                    successMsg += `‚Ä¢ Revit Data - ${mappedData.length} rows\n` +
                          '‚Ä¢ All formatting preserved! ‚úì';
                    
                    alert(successMsg);
                } catch (templateError) {
                    console.log('Template not available, using basic generation:', templateError.message);
                    
                    // Fall back to basic generation
                    const wb = XLSX.utils.book_new();
                    createBOMAMethodB(wb, allFloors, sourceFloorLookup, projectInfo);
                    createBOMAMethodA(wb, allFloors, sourceFloorLookup, projectInfo);
                    
                    const wsData = XLSX.utils.json_to_sheet(mappedData);
                    XLSX.utils.book_append_sheet(wb, wsData, 'Revit Data');
                    
                    const timestamp = new Date().toISOString().split('T')[0];
                    XLSX.writeFile(wb, `BOMA_Calculations_${timestamp}.xlsx`, { 
                        bookType: 'xlsx', 
                        cellFormula: true 
                    });
                    
                    alert('‚úì BOMA Excel generated!\n\n' +
                          `‚Ä¢ HKS-BOMA-B - ${allFloors.length} floors\n` +
                          `‚Ä¢ HKS-BOMA-A - ${allFloors.length} floors\n` +
                          `‚Ä¢ Revit Data - ${mappedData.length} rows\n\n` +
                          'Note: Upload BOMA_Template.xlsx to GitHub for formatted output');
                }
                
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
            } catch (error) {
                console.error(error);
                alert('Error: ' + error.message);
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
            }
        }
        
        async function generateWithTemplate(floors, sourceFloorLookup, mappedData, projectInfo) {
            // Fetch template from GitHub
            const response = await fetch(TEMPLATE_URL);
            if (!response.ok) {
                throw new Error('Template not found - upload BOMA_Template.xlsx to GitHub');
            }
            
            const arrayBuffer = await response.arrayBuffer();
            
            // Use ExcelJS to load and modify template (preserves formatting!)
            const workbook = new ExcelJS.Workbook();
            await workbook.xlsx.load(arrayBuffer);
            
            const wsB = workbook.getWorksheet('HKS-BOMA-B');
            const wsA = workbook.getWorksheet('HKS-BOMA-A');
            const wsData = workbook.getWorksheet('Revit Data');
            
            // Update project info (preserves cell formatting)
            const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            
            if (wsB) {
                wsB.getCell('A1').value = projectInfo.name;
                wsB.getCell('A2').value = projectInfo.location;
                wsB.getCell('A3').value = `HKS Project# ${projectInfo.number}`;
                wsB.getCell('B2').value = dateStr;  // Date moved to B2
                
                // Populate BOMA-B data
                populateBOMAMethodB_ExcelJS(wsB, floors);
                
                // Hide unused rows between efficiency and old template rows
                const keepUntilB = 9 + floors.length + 2; // First row after efficiency
                for (let rowNum = keepUntilB; rowNum <= 70; rowNum++) {
                    const row = wsB.getRow(rowNum);
                    row.hidden = true;
                }
            }
            
            if (wsA) {
                wsA.getCell('A1').value = projectInfo.name;
                wsA.getCell('A2').value = projectInfo.location;
                wsA.getCell('A3').value = `HKS Project# ${projectInfo.number}`;
                wsA.getCell('B2').value = dateStr;  // Date moved to B2
                
                // Populate BOMA-A data
                populateBOMAMethodA_ExcelJS(wsA, floors);
                
                // Hide unused rows between efficiency and old template rows
                const keepUntilA = 9 + floors.length + 2; // First row after efficiency
                for (let rowNum = keepUntilA; rowNum <= 70; rowNum++) {
                    const row = wsA.getRow(rowNum);
                    row.hidden = true;
                }
            }
            
            if (wsData) {
                // Prepare data rows
                const dataRows = mappedData.map(row => {
                    const areaType = row.Name;
                    const isBomaType = EXPECTED_AREA_TYPES.some(exp => exp.toUpperCase() === areaType.toUpperCase());
                    return {
                        FloorMap: row.FloorMap,
                        Name: row.Name,
                        Area: isBomaType ? row.Area : 0,
                        'NON BOMA Areas': isBomaType ? 0 : row.Area,
                        'Area Scheme Name': row['Area Scheme Name']
                    };
                });
                
                // Write data starting at row 2 (after header in row 1)
                // If template has an Excel Table named "RevitData", Excel will auto-expand it
                // when it detects data in contiguous rows below the header
                dataRows.forEach((row, idx) => {
                    const rowNum = idx + 2;
                    wsData.getCell(`A${rowNum}`).value = row.FloorMap;
                    wsData.getCell(`B${rowNum}`).value = row.Name;
                    wsData.getCell(`C${rowNum}`).value = row.Area;
                    wsData.getCell(`D${rowNum}`).value = row['NON BOMA Areas'];
                    wsData.getCell(`E${rowNum}`).value = row['Area Scheme Name'];
                });
            }
            
            // Handle NON-BOMA Areas tab
            const wsNonBoma = workbook.getWorksheet('NON-BOMA Areas');
            
            // Get selected non-standard types
            const selectedNonStandard = nonStandardTypes.filter(t => selectedAreaTypes.includes(t));
            
            if (wsNonBoma) {
                if (selectedNonStandard.length === 0) {
                    // No non-standard types selected - try to remove the sheet
                    try {
                        workbook.removeWorksheet(wsNonBoma.id);
                    } catch (e) {
                        // If removal fails, just hide all content
                        console.log('Could not remove NON-BOMA sheet, leaving blank');
                    }
                } else {
                    // Filter floors to only those with data for selected non-standard types
                    const floorsWithNonBomaData = floors.filter(floor => {
                        // Check if this floor has any data for selected non-standard types
                        // Use OriginalName since selectedNonStandard contains original type names
                        return mappedData.some(row => 
                            row.FloorMap === floor && 
                            selectedNonStandard.includes(row.OriginalName) &&
                            row.Area > 0
                        );
                    });
                    
                    if (floorsWithNonBomaData.length === 0) {
                        // No floors have non-BOMA data - remove the sheet
                        try {
                            workbook.removeWorksheet(wsNonBoma.id);
                        } catch (e) {
                            console.log('Could not remove NON-BOMA sheet, leaving blank');
                        }
                    } else {
                        // Populate NON-BOMA Areas tab
                        wsNonBoma.getCell('A1').value = projectInfo.name;
                        wsNonBoma.getCell('A2').value = projectInfo.location;
                        wsNonBoma.getCell('A3').value = `HKS Project# ${projectInfo.number}`;
                        wsNonBoma.getCell('B2').value = dateStr;
                        
                        populateNonBOMATab_ExcelJS(wsNonBoma, floorsWithNonBomaData, selectedNonStandard);
                    }
                }
            }
            
            // Generate buffer and download
            const buffer = await workbook.xlsx.writeBuffer();
            const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().split('T')[0];
            a.download = `BOMA_Calculations_${timestamp}.xlsx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function populateBOMAMethodB_ExcelJS(ws, floors) {
            const startRow = 9;
            const lastDataRow = startRow + floors.length - 1;
            const subTotalRow = startRow + floors.length; // Subtotal immediately after data
            
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                
                // Set values and formulas (formatting is preserved from template)
                ws.getCell(`A${row}`).value = floor;
                // Boundary Areas: Simple SUMIF since Column C only contains BOMA data
                ws.getCell(`B${row}`).value = { formula: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$C:$C)` };
                ws.getCell(`C${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")` };
                ws.getCell(`D${row}`).value = { formula: `B${row}-C${row}` };
                ws.getCell(`E${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")` };
                ws.getCell(`F${row}`).value = { formula: `D${row}-E${row}` };
                ws.getCell(`G${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")` };
                ws.getCell(`H${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")` };
                ws.getCell(`I${row}`).value = { formula: `IF($H$${subTotalRow}=0,0,($F$${subTotalRow}-$G$${subTotalRow})/$H$${subTotalRow})` };
                ws.getCell(`J${row}`).value = { formula: `G${row}+(H${row}*I${row})` };
            });
            
            // Write TOTALS formulas at the row immediately after data
            // (Don't overwrite A - preserve template's label by copying from row 69)
            ws.getCell(`A${subTotalRow}`).value = ws.getCell('A69').value || 'TOTALS';
            ws.getCell(`B${subTotalRow}`).value = { formula: `SUM(B${startRow}:B${lastDataRow})` };
            ws.getCell(`C${subTotalRow}`).value = { formula: `SUM(C${startRow}:C${lastDataRow})` };
            ws.getCell(`D${subTotalRow}`).value = { formula: `SUM(D${startRow}:D${lastDataRow})` };
            ws.getCell(`E${subTotalRow}`).value = { formula: `SUM(E${startRow}:E${lastDataRow})` };
            ws.getCell(`F${subTotalRow}`).value = { formula: `SUM(F${startRow}:F${lastDataRow})` };
            ws.getCell(`G${subTotalRow}`).value = { formula: `SUM(G${startRow}:G${lastDataRow})` };
            ws.getCell(`H${subTotalRow}`).value = { formula: `SUM(H${startRow}:H${lastDataRow})` };
            ws.getCell(`I${subTotalRow}`).value = { formula: `IF(H${subTotalRow}=0,0,(F${subTotalRow}-G${subTotalRow})/H${subTotalRow})` };
            ws.getCell(`J${subTotalRow}`).value = { formula: `SUM(J${startRow}:J${lastDataRow})` };
            
            // Copy formatting from template's subtotal row (69) to new subtotal row
            for (let col = 1; col <= 10; col++) {
                const templateCell = ws.getCell(69, col);
                const newCell = ws.getCell(subTotalRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
            
            // Copy Efficiency row from 70 to new position (subTotalRow + 1)
            const efficiencyRow = subTotalRow + 1;
            ws.getCell(`A${efficiencyRow}`).value = ws.getCell('A70').value || 'Efficiency';
            ws.getCell(`J${efficiencyRow}`).value = { formula: `IF(D${subTotalRow}=0,0,J${subTotalRow}/D${subTotalRow})` };
            // Copy formatting
            for (let col = 1; col <= 10; col++) {
                const templateCell = ws.getCell(70, col);
                const newCell = ws.getCell(efficiencyRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
        }
        
        function populateBOMAMethodA_ExcelJS(ws, floors) {
            const startRow = 9;
            const lastDataRow = startRow + floors.length - 1;
            const subTotalRow = startRow + floors.length; // Subtotal immediately after data
            
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                
                ws.getCell(`A${row}`).value = floor;
                // Boundary Areas: Simple SUMIF since Column C only contains BOMA data
                ws.getCell(`B${row}`).value = { formula: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$C:$C)` };
                ws.getCell(`C${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")` };
                ws.getCell(`D${row}`).value = { formula: `B${row}-C${row}` };
                ws.getCell(`E${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")` };
                ws.getCell(`F${row}`).value = { formula: `D${row}-E${row}` };
                ws.getCell(`G${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")` };
                ws.getCell(`H${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")` };
                ws.getCell(`I${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA")+SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA-DECK")` };
                ws.getCell(`J${row}`).value = { formula: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"FSA")+SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BBC")` };
                ws.getCell(`K${row}`).value = { formula: `IF(H${row}=0,0,(H${row}+J${row})/H${row})` };
                ws.getCell(`L${row}`).value = { formula: `H${row}*K${row}` };
                ws.getCell(`M${row}`).value = { formula: `IF(($F$${subTotalRow}-$G$${subTotalRow}-$I$${subTotalRow})=0,0,($F$${subTotalRow}-$G$${subTotalRow})/($F$${subTotalRow}-$G$${subTotalRow}-$I$${subTotalRow}))` };
                ws.getCell(`N${row}`).value = { formula: `G${row}+(L${row}*M${row})` };
                ws.getCell(`O${row}`).value = { formula: `IF(H${row}=0,0,N${row}/H${row})` };
            });
            
            // Write TOTAL formulas at the row immediately after data
            ws.getCell(`A${subTotalRow}`).value = ws.getCell('A69').value || 'TOTAL';
            ws.getCell(`B${subTotalRow}`).value = { formula: `SUM(B${startRow}:B${lastDataRow})` };
            ws.getCell(`C${subTotalRow}`).value = { formula: `SUM(C${startRow}:C${lastDataRow})` };
            ws.getCell(`D${subTotalRow}`).value = { formula: `SUM(D${startRow}:D${lastDataRow})` };
            ws.getCell(`E${subTotalRow}`).value = { formula: `SUM(E${startRow}:E${lastDataRow})` };
            ws.getCell(`F${subTotalRow}`).value = { formula: `SUM(F${startRow}:F${lastDataRow})` };
            ws.getCell(`G${subTotalRow}`).value = { formula: `SUM(G${startRow}:G${lastDataRow})` };
            ws.getCell(`H${subTotalRow}`).value = { formula: `SUM(H${startRow}:H${lastDataRow})` };
            ws.getCell(`I${subTotalRow}`).value = { formula: `SUM(I${startRow}:I${lastDataRow})` };
            ws.getCell(`J${subTotalRow}`).value = { formula: `SUM(J${startRow}:J${lastDataRow})` };
            ws.getCell(`K${subTotalRow}`).value = { formula: `IF(H${subTotalRow}=0,0,(H${subTotalRow}+J${subTotalRow})/H${subTotalRow})` };
            ws.getCell(`L${subTotalRow}`).value = { formula: `SUM(L${startRow}:L${lastDataRow})` };
            ws.getCell(`M${subTotalRow}`).value = { formula: `IF((F${subTotalRow}-G${subTotalRow}-I${subTotalRow})=0,0,(F${subTotalRow}-G${subTotalRow})/(F${subTotalRow}-G${subTotalRow}-I${subTotalRow}))` };
            ws.getCell(`N${subTotalRow}`).value = { formula: `SUM(N${startRow}:N${lastDataRow})` };
            // Note: Column O (Load Factor A) has no total - it's floor-specific
            
            // Copy formatting from template's subtotal row (69) to new subtotal row
            for (let col = 1; col <= 15; col++) {
                const templateCell = ws.getCell(69, col);
                const newCell = ws.getCell(subTotalRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
            
            // Copy Efficiency row from 70 to new position (subTotalRow + 1)
            const efficiencyRow = subTotalRow + 1;
            ws.getCell(`A${efficiencyRow}`).value = ws.getCell('A70').value || 'Efficiency';
            ws.getCell(`N${efficiencyRow}`).value = { formula: `IF(D${subTotalRow}=0,0,N${subTotalRow}/D${subTotalRow})` };
            // Copy formatting
            for (let col = 1; col <= 15; col++) {
                const templateCell = ws.getCell(70, col);
                const newCell = ws.getCell(efficiencyRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
        }
        
        function populateNonBOMATab_ExcelJS(ws, floors, nonStandardTypes) {
            // Template structure:
            // Row 1: A1=Project Name, B1=Title (already in template)
            // Row 2: A2=City, State, B2=Date
            // Row 3: A3=HKS Project#
            // Row 4: Column letters (A, B, C...)
            // Row 5: "Input" labels
            // Row 6: A6="BOMA Area Type", B6+=Type names
            // Row 7: A7="Floor Level", B7+="Boundary Areas (Overall)", last col="TOTALS by Level"
            // Row 8-27: Floor data (20 rows)
            // Row 28: "TOTALS by Type"
            
            const startRow = 8;
            const numTypes = nonStandardTypes.length;
            const numFloors = floors.length;
            const lastDataRow = startRow + numFloors - 1;
            const totalsRow = startRow + numFloors; // TOTALS by Type row
            const lastDataCol = 1 + numTypes; // Column A + type columns
            const totalsByLevelCol = lastDataCol + 1; // Column for row totals
            
            // Row 6: Area type names in columns B, C, D, etc.
            nonStandardTypes.forEach((type, idx) => {
                const col = 2 + idx; // B=2, C=3, etc.
                ws.getCell(6, col).value = type;
            });
            
            // Row 7: Update headers - "Boundary Areas (Overall)" for each type column, then "TOTALS by Level"
            nonStandardTypes.forEach((type, idx) => {
                const col = 2 + idx;
                ws.getCell(7, col).value = 'Boundary Areas (Overall)';
            });
            ws.getCell(7, totalsByLevelCol).value = 'TOTALS by Level';
            
            // Update column letters in Row 4
            for (let i = 0; i < numTypes + 2; i++) { // +2 for A column and totals column
                const col = 1 + i;
                ws.getCell(4, col).value = String.fromCharCode(64 + col); // A, B, C, etc.
            }
            
            // Update "Input" labels in Row 5
            for (let i = 0; i < numTypes; i++) {
                const col = 2 + i;
                ws.getCell(5, col).value = 'Input';
            }
            ws.getCell(5, totalsByLevelCol).value = ''; // Clear for totals column
            
            // Data rows - one per floor
            floors.forEach((floor, floorIdx) => {
                const row = startRow + floorIdx;
                
                // Column A: Floor name
                ws.getCell(row, 1).value = floor;
                
                // Columns B, C, D, etc.: SUMIFS formula for each non-standard type (using Column D = NON BOMA Areas)
                nonStandardTypes.forEach((type, typeIdx) => {
                    const col = 2 + typeIdx;
                    ws.getCell(row, col).value = { 
                        formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"${type}")` 
                    };
                });
                
                // TOTALS by Level column: SUM of all type columns for this row
                const startColLetter = 'B';
                const endColLetter = String.fromCharCode(65 + numTypes); // B + numTypes - 1
                ws.getCell(row, totalsByLevelCol).value = { 
                    formula: `SUM(${startColLetter}${row}:${endColLetter}${row})` 
                };
            });
            
            // TOTALS by Type row
            ws.getCell(totalsRow, 1).value = 'TOTALS by Type';
            
            // Sum each type column
            nonStandardTypes.forEach((type, typeIdx) => {
                const col = 2 + typeIdx;
                const colLetter = String.fromCharCode(65 + col - 1); // B, C, D, etc.
                ws.getCell(totalsRow, col).value = { 
                    formula: `SUM(${colLetter}${startRow}:${colLetter}${lastDataRow})` 
                };
            });
            
            // Grand total (bottom-right corner)
            const totalsByLevelColLetter = String.fromCharCode(65 + totalsByLevelCol - 1);
            ws.getCell(totalsRow, totalsByLevelCol).value = { 
                formula: `SUM(${totalsByLevelColLetter}${startRow}:${totalsByLevelColLetter}${lastDataRow})` 
            };
            
            // Copy formatting from template rows to actual data rows
            // Copy row 8 style to all data rows
            for (let rowNum = startRow; rowNum <= totalsRow; rowNum++) {
                for (let col = 1; col <= totalsByLevelCol; col++) {
                    const templateRow = rowNum === totalsRow ? 28 : 8; // Use row 28 style for totals, row 8 for data
                    const templateCell = ws.getCell(templateRow, col <= 9 ? col : 9);
                    const newCell = ws.getCell(rowNum, col);
                    if (templateCell.style) {
                        newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                    }
                }
            }
            
            // Hide unused columns after our TOTALS by Level column through template's column I (9)
            // Template has: A=Floor, B-H=7 type columns, I=TOTALS by Level
            // We use: A=Floor, B to (1+numTypes)=type columns, (2+numTypes)=TOTALS by Level
            for (let col = totalsByLevelCol + 1; col <= 9; col++) {
                ws.getColumn(col).hidden = true;
            }
            
            // Clear content in header rows for hidden columns (in case they're unhidden)
            for (let col = totalsByLevelCol + 1; col <= 9; col++) {
                ws.getCell(4, col).value = null; // Row 4 - column letters
                ws.getCell(5, col).value = null; // Row 5 - Input labels
                ws.getCell(6, col).value = null; // Row 6 - Type names
                ws.getCell(7, col).value = null; // Row 7 - Headers
            }
            
            // Hide unused rows (template has rows 8-27 for data, row 28 for totals)
            // If fewer floors, hide rows from totalsRow+1 to 28
            for (let rowNum = totalsRow + 1; rowNum <= 28; rowNum++) {
                ws.getRow(rowNum).hidden = true;
            }
        }
        
        function createBOMAMethodB(wb, floors, sourceFloorLookup, projectInfo) {
            const ws = {};
            const dateStr = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', month: 'long', day: 'numeric' 
            });
            
            // Row 1 - Project header
            ws['A1'] = { t: 's', v: projectInfo.name };
            ws['J1'] = { t: 's', v: 'Preliminary Global Summary Of Areas' };
            
            // Row 2 - Location and date
            ws['A2'] = { t: 's', v: projectInfo.location };
            ws['J2'] = { t: 's', v: dateStr };
            ws['K2'] = { t: 's', v: 'Per BOMA/ANSI Z65.1 2024-Method B (Modified HKS)' };
            
            // Row 3 - Project number
            ws['A3'] = { t: 's', v: `HKS Project# ${projectInfo.number}` };
            
            // Row 4 - Column letters
            const headers4 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'];
            headers4.forEach(h => {
                ws[h + '4'] = { t: 's', v: h };
            });
            
            // Row 5 - Formula descriptions
            const formulas5 = ['Input', 'Input', 'Input', 'B-C', 'Input', 'D-E', 'Input', 'Input', '(Œ£F-Œ£G)/Œ£H', 'G+(H*I)', 'Calculation'];
            formulas5.forEach((f, i) => {
                ws[String.fromCharCode(65 + i) + '5'] = { t: 's', v: f };
            });
            
            // Row 6 - Abbreviations
            const abbrev6 = ['PA', 'MVP', 'TA-BALC', 'TA', '', '', '', '', '', '', 'Area Plan Abbreviations & Wall Priorities'];
            abbrev6.forEach((a, i) => {
                if (a) ws[String.fromCharCode(65 + i) + '6'] = { t: 's', v: a };
            });
            
            // Row 7 - Full descriptions
            const desc7 = [
                '(Parking)', 'GSF', 'Stairs, Shafts, & Elevators', 'GSF-MVP (No Load Factor)',
                'Unenclosed Tenant Areas (Balconies)', 'Tenant Area (AKA Occupant Areas)',
                '', '', '', '', 'Explanation / Definitions'
            ];
            desc7.forEach((d, i) => {
                if (d) ws[String.fromCharCode(65 + i) + '7'] = { t: 's', v: d };
            });
            
            // Row 8 - Column headers
            const headers8 = [
                'Floor Level', 'Boundary Areas (Overall)', 'Boundary Area Exclusions',
                'Boundary Areas (Office)', 'Major Vertical Penetrations', 'Floor Rentable Area',
                'Non-Allocated Tenant Areas (Balconies)', 'Tenant / Occupant Useable Areas',
                'Load Factor B', 'Rentable Area', 'BOMA 2024 Space Classifications'
            ];
            headers8.forEach((h, i) => {
                ws[String.fromCharCode(65 + i) + '8'] = { t: 's', v: h };
            });
            
            // Data rows starting at row 9
            const startRow = 9;
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                
                // Formulas reference the building floor name (data is duplicated in Revit Data)
                ws['A' + rowStr] = { t: 's', v: floor };
                // Boundary Areas: Simple SUMIF since Column C only contains BOMA data
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$C:$C)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                
                const subRowRef = (startRow + floors.length).toString();
                ws['I' + rowStr] = { t: 'n', f: `IF($H$${subRowRef}=0,0,($F$${subRowRef}-$G$${subRowRef})/$H$${subRowRef})`, z: '0.0000' };
                ws['J' + rowStr] = { t: 'n', f: `G${rowStr}+(H${rowStr}*I${rowStr})`, z: '#,##0' };
            });
            
            // Subtotal row
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(F${subRow}-G${subRow})/H${subRow})`, z: '0.0000' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            
            ws['!cols'] = [
                { wch: 25 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
                { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 30 }
            ];
            
            ws['!ref'] = `A1:K${subRow}`;
            
            XLSX.utils.book_append_sheet(wb, ws, 'HKS-BOMA-B');
        }
        
        function createBOMAMethodA(wb, floors, sourceFloorLookup, projectInfo) {
            const ws = {};
            const dateStr = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', month: 'long', day: 'numeric' 
            });
            
            // Header rows
            ws['A1'] = { t: 's', v: projectInfo.name };
            ws['O1'] = { t: 's', v: 'Preliminary Global Summary Of Areas' };
            
            ws['A2'] = { t: 's', v: projectInfo.location };
            ws['O2'] = { t: 's', v: dateStr };
            ws['P2'] = { t: 's', v: 'Per BOMA/ANSI Z65.1 2024-Method A (Modified HKS)' };
            
            ws['A3'] = { t: 's', v: `HKS Project# ${projectInfo.number}` };
            
            // Row 4 - Column letters
            const headers4 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'];
            headers4.forEach(h => {
                ws[h + '4'] = { t: 's', v: h };
            });
            
            // Row 5 - Formula descriptions
            const formulas5 = ['Input', 'Input', 'Input', 'B-C', 'Input', 'D-E', 'Input', 'Input', 'Input', 'Input', '(H+J)/H', 'H*K', '(Œ£F-Œ£G)/(Œ£F-Œ£G-Œ£I)', 'G+(L*M)', 'N/H', 'Calculation'];
            formulas5.forEach((f, i) => {
                ws[String.fromCharCode(65 + i) + '5'] = { t: 's', v: f };
            });
            
            // Row 6 - Abbreviations
            const abbrev6 = ['PA', 'MVP', 'TA-BALC', 'TA', 'BSA', 'FSA', '', '', '', '', '', '', '', '', '', 'Area Plan Abbreviations'];
            abbrev6.forEach((a, i) => {
                if (a) ws[String.fromCharCode(65 + i) + '6'] = { t: 's', v: a };
            });
            
            // Row 8 - Column headers
            const headers8 = [
                'Floor Level', 'Boundary Areas (Overall)', 'Boundary Area Exclusions',
                'Boundary Areas (Office)', 'Major Vertical Penetrations', 'Floor Rentable Area',
                'Non-Allocated Tenant Areas (Balconies)', 'Occupant Useable Areas',
                'Building Service Areas', 'Floor Service Area', 'Floor Allocation Ratio',
                'Floor Allocation', 'Building Allocation Ratio', 'Rentable Area',
                'Load Factor A', 'BOMA 2024 Space Classifications'
            ];
            headers8.forEach((h, i) => {
                ws[String.fromCharCode(65 + i) + '8'] = { t: 's', v: h };
            });
            
            // Data rows
            const startRow = 9;
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                const subRowRef = (startRow + floors.length).toString();
                
                ws['A' + rowStr] = { t: 's', v: floor };
                // Boundary Areas: Simple SUMIF since Column C only contains BOMA data
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$C:$C)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                ws['I' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA")+SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA-DECK")`, z: '#,##0' };
                ws['J' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"FSA")+SUMIFS('Revit Data'!$C:$C,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BBC")`, z: '#,##0' };
                ws['K' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,(H${rowStr}+J${rowStr})/H${rowStr})`, z: '0.0000' };
                ws['L' + rowStr] = { t: 'n', f: `H${rowStr}*K${rowStr}`, z: '#,##0' };
                ws['M' + rowStr] = { t: 'n', f: `IF(($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef})=0,0,($F$${subRowRef}-$G$${subRowRef})/($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef}))`, z: '0.0000' };
                ws['N' + rowStr] = { t: 'n', f: `G${rowStr}+(L${rowStr}*M${rowStr})`, z: '#,##0' };
                ws['O' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,N${rowStr}/H${rowStr})`, z: '0.0000' };
            });
            
            // Subtotal row
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `SUM(I${startRow}:I${lastDataRow})`, z: '#,##0' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            ws['K' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(H${subRow}+J${subRow})/H${subRow})`, z: '0.0000' };
            ws['L' + subRow] = { t: 'n', f: `SUM(L${startRow}:L${lastDataRow})`, z: '#,##0' };
            ws['M' + subRow] = { t: 'n', f: `IF((F${subRow}-G${subRow}-I${subRow})=0,0,(F${subRow}-G${subRow})/(F${subRow}-G${subRow}-I${subRow}))`, z: '0.0000' };
            ws['N' + subRow] = { t: 'n', f: `SUM(N${startRow}:N${lastDataRow})`, z: '#,##0' };
            ws['O' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,N${subRow}/H${subRow})`, z: '0.0000' };
            
            ws['!cols'] = Array(16).fill({ wch: 11 });
            ws['!cols'][0] = { wch: 25 };
            ws['!cols'][15] = { wch: 30 };
            
            ws['!ref'] = `A1:P${subRow}`;
            
            XLSX.utils.book_append_sheet(wb, ws, 'HKS-BOMA-A');
        }
    </script>
</body>
</html>
