<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKS BOMA Calculator</title>
    
    <!-- SheetJS Library from CDN -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --hks-grey: #7B797D;
            --hks-dark: #3a3a3a;
            --hks-light: #f5f5f5;
            --accent: #2196F3;
            --success: #4CAF50;
            --warning: #FF9800;
            --error: #f44336;
            --border: #e0e0e0;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: var(--hks-grey);
            color: white;
            padding: 30px 40px;
            border-bottom: 4px solid var(--hks-dark);
        }
        
        .header h1 { font-size: 32px; font-weight: 600; margin-bottom: 8px; }
        .header p { opacity: 0.95; font-size: 15px; }
        
        .content { padding: 40px; }
        
        .step { margin-bottom: 40px; padding-bottom: 40px; border-bottom: 1px solid var(--border); }
        .step:last-child { border-bottom: none; }
        
        .step-header { display: flex; align-items: center; margin-bottom: 20px; }
        .step-number {
            width: 40px; height: 40px;
            background: var(--hks-grey);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 15px;
            font-size: 18px;
        }
        .step-title { font-size: 22px; color: var(--hks-dark); font-weight: 600; }
        
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 50px;
            text-align: center;
            background: var(--hks-light);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-zone:hover { border-color: var(--accent); background: #e3f2fd; }
        .upload-icon { font-size: 56px; margin-bottom: 15px; }
        .upload-text { font-size: 18px; color: var(--hks-dark); margin-bottom: 8px; font-weight: 500; }
        input[type="file"] { display: none; }
        
        .file-info {
            display: none;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 8px;
            margin-top: 20px;
        }
        .file-info.active { display: flex; }
        
        .mapping-container {
            background: var(--hks-light);
            border-radius: 8px;
            padding: 25px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .floor-item {
            background: white;
            padding: 18px 20px;
            margin-bottom: 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            cursor: grab;
        }
        .floor-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        .floor-item.dragging { opacity: 0.5; cursor: grabbing; }
        .floor-item.drag-over { border-top: 3px solid var(--accent); }
        
        .drag-handle {
            cursor: grab;
            padding: 5px;
            color: var(--hks-grey);
            font-size: 18px;
        }
        
        .floor-label {
            min-width: 200px;
            font-weight: 500;
            color: var(--hks-dark);
            padding: 8px 12px;
            background: var(--hks-light);
            border-radius: 4px;
        }
        
        .floor-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 15px;
            font-family: Arial, sans-serif;
        }
        .floor-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        .floor-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .action-btn {
            padding: 8px 14px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }
        .action-btn:hover { background: var(--hks-light); }
        .action-btn.remove:hover { background: #ffebee; border-color: var(--error); color: var(--error); }
        
        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: #1976D2; transform: translateY(-2px); }
        .btn-success { background: var(--success); color: white; }
        .btn-success:hover { background: #45a049; transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .hidden { display: none !important; }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid var(--accent);
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            text-align: center;
        }
        .stat-value {
            font-size: 32px;
            font-weight: 600;
            color: var(--hks-grey);
            margin-bottom: 5px;
        }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>BOMA Calculator</h1>
            <p>Convert Revit area exports to BOMA-compliant calculation spreadsheets</p>
        </div>
        
        <div class="content">
            <!-- Step 1: Upload -->
            <div class="step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <div class="step-title">Upload Revit Export</div>
                </div>
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Click to browse or drag and drop</div>
                    <div class="upload-hint" style="font-size: 14px; color: #666;">Excel (.xlsx, .xls) or CSV</div>
                </div>
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv">
                <div class="file-info" id="fileInfo">
                    <span style="font-size: 32px; color: var(--success);">‚úì</span>
                    <div>
                        <h3 id="fileName" style="font-size: 16px; margin-bottom: 4px;"></h3>
                        <p id="fileDetails" style="font-size: 14px; color: #666;"></p>
                    </div>
                </div>
            </div>
            
            <!-- Step 2: Map Floors -->
            <div class="step hidden" id="step2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <div class="step-title">Map Building Floors</div>
                </div>
                <div class="info-box">
                    <p><strong>Instructions:</strong> Floors auto-sorted (Roof ‚Üí Floors ‚Üí Ground ‚Üí Basements). <strong>Drag-and-drop</strong> to reorder, or add/remove floors as needed.</p>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalLevels">0</div>
                        <div style="font-size: 13px; color: #666;">REVIT LEVELS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalRows">0</div>
                        <div style="font-size: 13px; color: #666;">DATA ROWS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalFloors">0</div>
                        <div style="font-size: 13px; color: #666;">MAPPED FLOORS</div>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <button class="btn" style="background: var(--hks-grey); color: white;" onclick="autoSortFloors()">
                        <span>‚áÖ</span> Auto-Sort
                    </button>
                    <button class="btn" style="background: white; color: var(--hks-dark); border: 1px solid var(--border);" onclick="resetMappings()">
                        <span>‚Ü∫</span> Reset
                    </button>
                </div>
                <div class="mapping-container" id="mappingContainer"></div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn btn-primary" onclick="proceedToGenerate()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 3: Generate -->
            <div class="step hidden" id="step3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <div class="step-title">Generate BOMA Spreadsheet</div>
                </div>
                <div class="info-box" style="background: #fff3e0; border-left-color: var(--warning);">
                    <p><strong>Ready:</strong> Excel file will include BOMA Method A & B calculations with formulas, plus your Revit data.</p>
                </div>
                <button class="btn btn-success" id="generateBtn" onclick="generateExcel()">
                    <span>üìä</span> Generate Excel with Formulas
                </button>
                <div style="margin-top: 20px;">
                    <button class="btn" style="background: var(--hks-grey); color: white;" onclick="showStep(2)">
                        ‚Üê Back
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let workbookData = null;
        let rawData = [];
        let revitLevels = [];
        let floorMappings = [];
        let levelColumn = null;
        let originalMappings = [];
        let draggedIndex = null;
        
        // DOM elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const mappingContainer = document.getElementById('mappingContainer');
        
        // Upload handlers
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.style.borderColor = 'var(--accent)'; });
        uploadZone.addEventListener('dragleave', () => uploadZone.style.borderColor = '');
        uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            uploadZone.style.borderColor = '';
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', e => { if (e.target.files[0]) handleFile(e.target.files[0]); });
        
        function handleFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['xlsx', 'xls', 'csv'].includes(ext)) {
                alert('Please upload Excel or CSV file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    workbookData = workbook;
                    
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { defval: '' });
                    
                    if (jsonData.length === 0) {
                        alert('File is empty');
                        return;
                    }
                    
                    rawData = jsonData;
                    levelColumn = Object.keys(jsonData[0]).find(k => k.toLowerCase().includes('level'));
                    
                    if (!levelColumn) {
                        alert('No "Level" column found');
                        return;
                    }
                    
                    // Extract levels (FIXED: allow short names like "P3")
                    revitLevels = [];
                    const seen = {};
                    jsonData.forEach(row => {
                        const level = row[levelColumn];
                        if (level && typeof level === 'string' && level.trim().length > 0 &&
                            !level.startsWith('(Instance)') && !seen[level]) {
                            seen[level] = true;
                            revitLevels.push(level);
                        }
                    });
                    
                    if (revitLevels.length === 0) {
                        alert('No valid levels found');
                        return;
                    }
                    
                    document.getElementById('fileName').textContent = file.name;
                    document.getElementById('fileDetails').textContent = `${revitLevels.length} levels ‚Ä¢ ${jsonData.length} rows`;
                    document.getElementById('fileInfo').classList.add('active');
                    document.getElementById('totalLevels').textContent = revitLevels.length;
                    document.getElementById('totalRows').textContent = jsonData.length;
                    
                    initializeFloorMappings();
                    showStep(2);
                } catch (error) {
                    alert('Error: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        function initializeFloorMappings() {
            floorMappings = revitLevels.map(level => ({
                revitLevel: level,
                buildingFloor: level,
                isNew: false
            }));
            
            // Auto-sort on load
            floorMappings.sort((a, b) => compareFloors(a.buildingFloor, b.buildingFloor));
            originalMappings = JSON.parse(JSON.stringify(floorMappings));
            renderFloorMappings();
        }
        
        function compareFloors(f1, f2) {
            const info1 = analyzeFloor(f1);
            const info2 = analyzeFloor(f2);
            if (info1.category !== info2.category) return info1.category - info2.category;
            if (info1.category === 3) return info2.number - info1.number; // Regular floors: high to low
            return info1.number - info2.number; // Basements: B1, B2, B3...
        }
        
        function analyzeFloor(name) {
            const n = name.toUpperCase();
            if (n.includes('ROOF')) return { category: 0, number: 0 };
            if (n.includes('PENTHOUSE') || n.includes('MECHANICAL') || n.includes('MACHINE') || n.includes('PH'))
                return { category: 1, number: 0 };
            if (n.includes('GROUND') || n.includes('LOBBY') || n.includes('MAIN') || n === 'G' || n === 'L')
                return { category: 4, number: 0 };
            
            const bMatch = n.match(/B[-\s]?(\d+)/i);
            if (bMatch) return { category: 5, number: parseInt(bMatch[1]) };
            
            const fMatch = n.match(/(?:LEVEL|L|P|FLOOR)[-\s]?(\d+)/i) || n.match(/^(\d+)/);
            if (fMatch) return { category: 3, number: parseInt(fMatch[1]) };
            
            return { category: 3, number: 0 };
        }
        
        function autoSortFloors() {
            floorMappings.sort((a, b) => compareFloors(a.buildingFloor, b.buildingFloor));
            renderFloorMappings();
        }
        
        function resetMappings() {
            if (confirm('Reset all changes?')) {
                floorMappings = JSON.parse(JSON.stringify(originalMappings));
                renderFloorMappings();
            }
        }
        
        function renderFloorMappings() {
            mappingContainer.innerHTML = '';
            floorMappings.forEach((m, i) => {
                const div = document.createElement('div');
                div.className = 'floor-item';
                div.draggable = true;
                div.dataset.index = i;
                
                div.innerHTML = `
                    <div class="drag-handle">‚ãÆ‚ãÆ</div>
                    <div class="floor-label">${m.isNew ? '(New)' : m.revitLevel}</div>
                    <div style="font-size: 24px; color: var(--hks-grey);">‚Üí</div>
                    <input type="text" class="floor-input" value="${m.buildingFloor}"
                           onchange="updateFloorName(${i}, this.value)"
                           placeholder="Floor name">
                    <div class="floor-actions">
                        <button class="action-btn" onclick="addFloorAbove(${i})">+ Above</button>
                        <button class="action-btn" onclick="addFloorBelow(${i})">+ Below</button>
                        <button class="action-btn remove" onclick="removeFloor(${i})">‚úï</button>
                    </div>
                `;
                
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);
                
                mappingContainer.appendChild(div);
            });
            
            document.getElementById('totalFloors').textContent = floorMappings.length;
        }
        
        function handleDragStart(e) {
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            document.querySelectorAll('.floor-item').forEach(el => el.classList.remove('drag-over'));
            this.classList.add('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            const dropIndex = parseInt(this.dataset.index);
            if (draggedIndex !== null && draggedIndex !== dropIndex) {
                const item = floorMappings[draggedIndex];
                floorMappings.splice(draggedIndex, 1);
                floorMappings.splice(draggedIndex < dropIndex ? dropIndex - 1 : dropIndex, 0, item);
                renderFloorMappings();
            }
        }
        
        function handleDragEnd() {
            this.classList.remove('dragging');
            document.querySelectorAll('.floor-item').forEach(el => el.classList.remove('drag-over'));
            draggedIndex = null;
        }
        
        function updateFloorName(i, v) { floorMappings[i].buildingFloor = v.trim(); }
        
        function addFloorAbove(i) {
            const nextName = getNextFloorName(floorMappings[i].buildingFloor, 'above');
            floorMappings.splice(i, 0, { revitLevel: '(New)', buildingFloor: nextName, isNew: true });
            renderFloorMappings();
        }
        
        function addFloorBelow(i) {
            const nextName = getNextFloorName(floorMappings[i].buildingFloor, 'below');
            floorMappings.splice(i + 1, 0, { revitLevel: '(New)', buildingFloor: nextName, isNew: true });
            renderFloorMappings();
        }
        
        function getNextFloorName(currentName, direction) {
            const num = currentName.match(/\d+/);
            if (!num) return currentName + ' (Copy)';
            
            const n = parseInt(num[0]);
            const prefix = currentName.substring(0, currentName.indexOf(num[0]));
            const suffix = currentName.substring(currentName.indexOf(num[0]) + num[0].length);
            
            const isBasement = currentName.toUpperCase().includes('B');
            let newNum;
            
            if (isBasement) {
                newNum = direction === 'above' ? n - 1 : n + 1;
            } else {
                newNum = direction === 'above' ? n + 1 : n - 1;
            }
            
            return newNum > 0 ? prefix + newNum + suffix : currentName + ' (Copy)';
        }
        
        function removeFloor(i) {
            if (confirm('Remove this floor?')) {
                floorMappings.splice(i, 1);
                renderFloorMappings();
            }
        }
        
        function showStep(n) {
            document.querySelectorAll('.step').forEach(el => el.classList.add('hidden'));
            document.getElementById(n === 2 ? 'step2' : 'step3').classList.remove('hidden');
        }
        
        function proceedToGenerate() {
            const empty = floorMappings.filter(m => !m.buildingFloor.trim());
            if (empty.length > 0) {
                alert(`Please name all ${empty.length} floor(s)`);
                return;
            }
            showStep(3);
        }
        
        // Template URL - upload BOMA_Template.xlsx to GitHub for formatted output
        const TEMPLATE_URL = 'https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/BOMA_Template.xlsx';
        
        async function generateExcel() {
            try {
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<span class="spinner"></span> Generating...';
                
                // Build mapping lookup and reverse lookup for new floors
                const mappingLookup = {};  // Revit level -> Building floor
                const sourceFloorLookup = {};  // Building floor -> Source Revit level
                
                floorMappings.forEach(m => {
                    if (!m.isNew) {
                        // Original floors
                        mappingLookup[m.revitLevel] = m.buildingFloor;
                        sourceFloorLookup[m.buildingFloor] = m.revitLevel;
                    } else {
                        // New floors - find which original floor they should use
                        // For now, we'll mark them to inherit from the floor above them
                        // This can be enhanced with explicit mapping UI later
                        sourceFloorLookup[m.buildingFloor] = null;  // Will be filled later
                    }
                });
                
                // For new floors, find their source floor
                // Strategy: Look BELOW first (in the building hierarchy), then above
                // This ensures "Add Above" on L6 makes L7-L12 all use L6
                floorMappings.forEach((m, idx) => {
                    if (m.isNew) {
                        let sourceFloor = null;
                        
                        // First pass: Search BELOW in array (which is BELOW in building after sorting)
                        for (let i = idx + 1; i < floorMappings.length; i++) {
                            if (!floorMappings[i].isNew) {
                                sourceFloor = floorMappings[i].revitLevel;
                                break;
                            }
                        }
                        
                        // Second pass: If nothing found below, search ABOVE
                        if (!sourceFloor) {
                            for (let i = idx - 1; i >= 0; i--) {
                                if (!floorMappings[i].isNew) {
                                    sourceFloor = floorMappings[i].revitLevel;
                                    break;
                                }
                            }
                        }
                        
                        if (sourceFloor) {
                            sourceFloorLookup[m.buildingFloor] = sourceFloor;
                        }
                    }
                });
                
                // Process data with floor mappings
                const mappedData = rawData.filter(row => {
                    const level = row[levelColumn];
                    return level && typeof level === 'string' && level.trim().length > 0 &&
                           !level.startsWith('(Instance)') && mappingLookup[level];
                }).map(row => ({
                    FloorMap: mappingLookup[row[levelColumn]],
                    Name: row.Name || '',
                    'Area Scheme Name': row['Area Scheme Name'] || '',
                    Area: parseFloat(row.Area) || 0
                }));
                
                if (mappedData.length === 0) {
                    alert('No data to export');
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
                    return;
                }
                
                // Get all floors from floorMappings (includes new floors)
                const allFloors = floorMappings.map(m => m.buildingFloor);
                
                // Try template first, fall back to basic generation
                try {
                    await generateWithTemplate(allFloors, sourceFloorLookup, mappedData);
                    alert('‚úì BOMA Excel generated with formatting!\n\n' +
                          `‚Ä¢ HKS-BOMA-B - ${allFloors.length} floors\n` +
                          `‚Ä¢ HKS-BOMA-A - ${allFloors.length} floors\n` +
                          '‚Ä¢ Revit Data\n' +
                          '‚Ä¢ All formatting preserved! ‚úì');
                } catch (templateError) {
                    console.log('Template not available, using basic generation:', templateError.message);
                    
                    // Fall back to basic generation
                    const wb = XLSX.utils.book_new();
                    createBOMAMethodB(wb, allFloors, sourceFloorLookup);
                    createBOMAMethodA(wb, allFloors, sourceFloorLookup);
                    
                    const wsData = XLSX.utils.json_to_sheet(mappedData);
                    XLSX.utils.book_append_sheet(wb, wsData, 'Revit Data');
                    
                    const timestamp = new Date().toISOString().split('T')[0];
                    XLSX.writeFile(wb, `BOMA_Calculations_${timestamp}.xlsx`, { 
                        bookType: 'xlsx', 
                        cellFormula: true 
                    });
                    
                    alert('‚úì BOMA Excel generated!\n\n' +
                          `‚Ä¢ HKS-BOMA-B - ${allFloors.length} floors\n` +
                          `‚Ä¢ HKS-BOMA-A - ${allFloors.length} floors\n` +
                          '‚Ä¢ Revit Data\n\n' +
                          'Note: Upload BOMA_Template.xlsx to GitHub for formatted output');
                }
                
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
            } catch (error) {
                console.error(error);
                alert('Error: ' + error.message);
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
            }
        }
        
        async function generateWithTemplate(floors, sourceFloorLookup, mappedData) {
            // Fetch template from GitHub
            const response = await fetch(TEMPLATE_URL);
            if (!response.ok) {
                throw new Error('Template not found - upload BOMA_Template.xlsx to GitHub');
            }
            
            const arrayBuffer = await response.arrayBuffer();
            const data = new Uint8Array(arrayBuffer);
            const wb = XLSX.read(data, { type: 'array', cellStyles: true });
            
            // Populate BOMA-B
            populateBOMAMethodB(wb, floors, sourceFloorLookup);
            
            // Populate BOMA-A  
            populateBOMAMethodA(wb, floors, sourceFloorLookup);
            
            // Populate Revit Data
            const wsData = wb.Sheets['Revit Data'];
            const dataRange = XLSX.utils.decode_range(wsData['!ref']);
            for (let R = 1; R <= dataRange.e.r; R++) {
                for (let C = 0; C <= 3; C++) {
                    const cellAddr = XLSX.utils.encode_cell({ r: R, c: C });
                    delete wsData[cellAddr];
                }
            }
            
            mappedData.forEach((row, idx) => {
                const rowNum = idx + 2;
                wsData[`A${rowNum}`] = { t: 's', v: row.FloorMap };
                wsData[`B${rowNum}`] = { t: 's', v: row.Name };
                wsData[`C${rowNum}`] = { t: 's', v: row['Area Scheme Name'] };
                wsData[`D${rowNum}`] = { t: 'n', v: row.Area, z: '#,##0' };
            });
            wsData['!ref'] = `A1:D${mappedData.length + 1}`;
            
            // Update dates
            const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            if (wb.Sheets['HKS-BOMA-B']['J2']) wb.Sheets['HKS-BOMA-B']['J2'].v = dateStr;
            if (wb.Sheets['HKS-BOMA-A']['O2']) wb.Sheets['HKS-BOMA-A']['O2'].v = dateStr;
            
            // Download
            const timestamp = new Date().toISOString().split('T')[0];
            XLSX.writeFile(wb, `BOMA_Calculations_${timestamp}.xlsx`, { bookType: 'xlsx', cellStyles: true });
        }
        
        function populateBOMAMethodB(wb, floors, sourceFloorLookup) {
            const ws = wb.Sheets['HKS-BOMA-B'];
            const startRow = 9;
            
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                const sourceFloor = sourceFloorLookup[floor] || floor;
                
                ws['A' + rowStr] = { t: 's', v: floor };
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$D:$D)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                const subRowRef = (startRow + floors.length).toString();
                ws['I' + rowStr] = { t: 'n', f: `IF($H$${subRowRef}=0,0,($F$${subRowRef}-$G$${subRowRef})/$H$${subRowRef})`, z: '0.0000' };
                ws['J' + rowStr] = { t: 'n', f: `G${rowStr}+(H${rowStr}*I${rowStr})`, z: '#,##0' };
            });
            
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(F${subRow}-G${subRow})/H${subRow})`, z: '0.0000' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            
            ws['!ref'] = `A1:K${subRow}`;
        }
        
        function populateBOMAMethodA(wb, floors, sourceFloorLookup) {
            const ws = wb.Sheets['HKS-BOMA-A'];
            const startRow = 9;
            
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                const subRowRef = (startRow + floors.length).toString();
                const sourceFloor = sourceFloorLookup[floor] || floor;
                
                ws['A' + rowStr] = { t: 's', v: floor };
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$D:$D)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                ws['I' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"BSA")`, z: '#,##0' };
                ws['J' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"FSA")+SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"BBC")`, z: '#,##0' };
                ws['K' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,(H${rowStr}+J${rowStr})/H${rowStr})`, z: '0.0000' };
                ws['L' + rowStr] = { t: 'n', f: `H${rowStr}*K${rowStr}`, z: '#,##0' };
                ws['M' + rowStr] = { t: 'n', f: `IF(($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef})=0,0,($F$${subRowRef}-$G$${subRowRef})/($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef}))`, z: '0.0000' };
                ws['N' + rowStr] = { t: 'n', f: `G${rowStr}+(L${rowStr}*M${rowStr})`, z: '#,##0' };
                ws['O' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,N${rowStr}/H${rowStr})`, z: '0.0000' };
            });
            
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `SUM(I${startRow}:I${lastDataRow})`, z: '#,##0' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            ws['K' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(H${subRow}+J${subRow})/H${subRow})`, z: '0.0000' };
            ws['L' + subRow] = { t: 'n', f: `SUM(L${startRow}:L${lastDataRow})`, z: '#,##0' };
            ws['M' + subRow] = { t: 'n', f: `IF((F${subRow}-G${subRow}-I${subRow})=0,0,(F${subRow}-G${subRow})/(F${subRow}-G${subRow}-I${subRow}))`, z: '0.0000' };
            ws['N' + subRow] = { t: 'n', f: `SUM(N${startRow}:N${lastDataRow})`, z: '#,##0' };
            ws['O' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,N${subRow}/H${subRow})`, z: '0.0000' };
            
            ws['!ref'] = `A1:P${subRow}`;
        }
        
        function createBOMAMethodB(wb, floors, sourceFloorLookup) {
            const ws = {};
            const dateStr = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', month: 'long', day: 'numeric' 
            });
            
            // Row 1 - Project header
            ws['A1'] = { t: 's', v: 'Project Name' };
            ws['J1'] = { t: 's', v: 'Preliminary Global Summary Of Areas' };
            
            // Row 2 - Location and date
            ws['A2'] = { t: 's', v: 'City, State' };
            ws['J2'] = { t: 's', v: dateStr };
            ws['K2'] = { t: 's', v: 'Per BOMA/ANSI Z65.1 2024-Method B (Modified HKS)' };
            
            // Row 3 - Project number
            ws['A3'] = { t: 's', v: 'HKS Project# 00000.000' };
            
            // Row 4 - Column letters
            const headers4 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'];
            headers4.forEach(h => {
                ws[h + '4'] = { t: 's', v: h };
            });
            
            // Row 5 - Formula descriptions
            const formulas5 = ['Input', 'Input', 'Input', 'B-C', 'Input', 'D-E', 'Input', 'Input', '(Œ£F-Œ£G)/Œ£H', 'G+(H*I)', 'Calculation'];
            formulas5.forEach((f, i) => {
                ws[String.fromCharCode(65 + i) + '5'] = { t: 's', v: f };
            });
            
            // Row 6 - Abbreviations
            const abbrev6 = ['PA', 'MVP', 'TA-BALC', 'TA', '', '', '', '', '', '', 'Area Plan Abbreviations & Wall Priorities'];
            abbrev6.forEach((a, i) => {
                if (a) ws[String.fromCharCode(65 + i) + '6'] = { t: 's', v: a };
            });
            
            // Row 7 - Full descriptions
            const desc7 = [
                '(Parking)', 'GSF', 'Stairs, Shafts, & Elevators', 'GSF-MVP (No Load Factor)',
                'Unenclosed Tenant Areas (Balconies), Tenant Storage/Lockers',
                'Tenant Area (AKA Occupant Areas)', '', '', '', '', 'Explanation / Definitions'
            ];
            desc7.forEach((d, i) => {
                if (d) ws[String.fromCharCode(65 + i) + '7'] = { t: 's', v: d };
            });
            
            // Row 8 - Column headers
            const headers8 = [
                'Floor Level', 'Boundary Areas (Overall)', 'Boundary Area Exclusions',
                'Boundary Areas (Office)', 'Major Vertical Penetrations', 'Floor Rentable Area',
                'Non-Allocated Tenant Areas (Balconies)', 'Tenant / Occupant Useable Areas',
                'Load Factor B', 'Rentable Area', 'BOMA 2024 Space Classifications'
            ];
            headers8.forEach((h, i) => {
                ws[String.fromCharCode(65 + i) + '8'] = { t: 's', v: h };
            });
            
            // Data rows starting at row 9
            const startRow = 9;
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                
                // Determine source floor for data lookups
                const sourceFloor = sourceFloorLookup[floor] || floor;
                
                // Column A - Floor name
                ws['A' + rowStr] = { t: 's', v: floor };
                
                // Column B - Total boundary area for this floor
                ws['B' + rowStr] = { 
                    t: 'n', 
                    f: `SUMIF('Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$D:$D)`,
                    z: '#,##0' 
                };
                
                // Column C - PA (Parking)
                ws['C' + rowStr] = { 
                    t: 'n', 
                    f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"PA")`,
                    z: '#,##0'
                };
                
                // Column D - B - C
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                
                // Column E - MVP
                ws['E' + rowStr] = { 
                    t: 'n', 
                    f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"MVP")`,
                    z: '#,##0'
                };
                
                // Column F - D - E  
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                
                // Column G - TA-BALC
                ws['G' + rowStr] = { 
                    t: 'n', 
                    f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA-BALC")`,
                    z: '#,##0'
                };
                
                // Column H - TA
                ws['H' + rowStr] = { 
                    t: 'n', 
                    f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA")`,
                    z: '#,##0'
                };
                
                // Column I - Load Factor B (references subtotal row)
                const subRowRef = (startRow + floors.length).toString();
                ws['I' + rowStr] = { 
                    t: 'n', 
                    f: `IF($H$${subRowRef}=0,0,($F$${subRowRef}-$G$${subRowRef})/$H$${subRowRef})`,
                    z: '0.0000'
                };
                
                // Column J - Rentable Area
                ws['J' + rowStr] = { t: 'n', f: `G${rowStr}+(H${rowStr}*I${rowStr})`, z: '#,##0' };
            });
            
            // Subtotal row
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(F${subRow}-G${subRow})/H${subRow})`, z: '0.0000' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            
            // Set column widths
            ws['!cols'] = [
                { wch: 25 }, // A - Floor Level
                { wch: 12 }, // B
                { wch: 12 }, // C
                { wch: 12 }, // D
                { wch: 12 }, // E
                { wch: 12 }, // F
                { wch: 12 }, // G
                { wch: 12 }, // H
                { wch: 12 }, // I
                { wch: 12 }, // J
                { wch: 30 }  // K - Classifications
            ];
            
            ws['!ref'] = `A1:K${subRow}`;
            
            XLSX.utils.book_append_sheet(wb, ws, 'HKS-BOMA-B');
        }
        
        function createBOMAMethodA(wb, floors, sourceFloorLookup) {
            const ws = {};
            const dateStr = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', month: 'long', day: 'numeric' 
            });
            
            // Header rows
            ws['A1'] = { t: 's', v: 'Project Name' };
            ws['O1'] = { t: 's', v: 'Preliminary Global Summary Of Areas' };
            
            ws['A2'] = { t: 's', v: 'City, State' };
            ws['O2'] = { t: 's', v: dateStr };
            ws['P2'] = { t: 's', v: 'Per BOMA/ANSI Z65.1 2024-Method A (Modified HKS)' };
            
            ws['A3'] = { t: 's', v: 'HKS Project# 00000.000' };
            
            // Row 4 - Column letters
            const headers4 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'];
            headers4.forEach(h => {
                ws[h + '4'] = { t: 's', v: h };
            });
            
            // Row 5 - Formula descriptions
            const formulas5 = ['Input', 'Input', 'Input', 'B-C', 'Input', 'D-E', 'Input', 'Input', 'Input', 'Input', '(H+J)/H', 'H*K', '(Œ£F-Œ£G)/(Œ£F-Œ£G-Œ£I)', 'G+(L*M)', 'N/H', 'Calculation'];
            formulas5.forEach((f, i) => {
                ws[String.fromCharCode(65 + i) + '5'] = { t: 's', v: f };
            });
            
            // Row 6 - Abbreviations
            const abbrev6 = ['PA', 'MVP', 'TA-BALC', 'TA', 'BSA', 'FSA', '', '', '', '', '', '', '', '', '', 'Area Plan Abbreviations'];
            abbrev6.forEach((a, i) => {
                if (a) ws[String.fromCharCode(65 + i) + '6'] = { t: 's', v: a };
            });
            
            // Row 8 - Column headers
            const headers8 = [
                'Floor Level', 'Boundary Areas (Overall)', 'Boundary Area Exclusions',
                'Boundary Areas (Office)', 'Major Vertical Penetrations', 'Floor Rentable Area',
                'Non-Allocated Tenant Areas (Balconies)', 'Occupant Useable Areas',
                'Building Service Areas', 'Floor Service Area', 'Floor Allocation Ratio',
                'Floor Allocation', 'Building Allocation Ratio', 'Rentable Area',
                'Load Factor A', 'BOMA 2024 Space Classifications'
            ];
            headers8.forEach((h, i) => {
                ws[String.fromCharCode(65 + i) + '8'] = { t: 's', v: h };
            });
            
            // Data rows
            const startRow = 9;
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                const subRowRef = (startRow + floors.length).toString();
                
                const sourceFloor = sourceFloorLookup[floor] || floor;
                
                ws['A' + rowStr] = { t: 's', v: floor };
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$D:$D)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                ws['I' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"BSA")`, z: '#,##0' };
                ws['J' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"FSA")+SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${sourceFloor}",'Revit Data'!$B:$B,"BBC")`, z: '#,##0' };
                ws['K' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,(H${rowStr}+J${rowStr})/H${rowStr})`, z: '0.0000' };
                ws['L' + rowStr] = { t: 'n', f: `H${rowStr}*K${rowStr}`, z: '#,##0' };
                ws['M' + rowStr] = { t: 'n', f: `IF(($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef})=0,0,($F$${subRowRef}-$G$${subRowRef})/($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef}))`, z: '0.0000' };
                ws['N' + rowStr] = { t: 'n', f: `G${rowStr}+(L${rowStr}*M${rowStr})`, z: '#,##0' };
                ws['O' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,N${rowStr}/H${rowStr})`, z: '0.0000' };
            });
            
            // Subtotal row
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `SUM(I${startRow}:I${lastDataRow})`, z: '#,##0' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            ws['K' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(H${subRow}+J${subRow})/H${subRow})`, z: '0.0000' };
            ws['L' + subRow] = { t: 'n', f: `SUM(L${startRow}:L${lastDataRow})`, z: '#,##0' };
            ws['M' + subRow] = { t: 'n', f: `IF((F${subRow}-G${subRow}-I${subRow})=0,0,(F${subRow}-G${subRow})/(F${subRow}-G${subRow}-I${subRow}))`, z: '0.0000' };
            ws['N' + subRow] = { t: 'n', f: `SUM(N${startRow}:N${lastDataRow})`, z: '#,##0' };
            ws['O' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,N${subRow}/H${subRow})`, z: '0.0000' };
            
            // Set column widths
            ws['!cols'] = Array(16).fill({ wch: 11 });
            ws['!cols'][0] = { wch: 25 }; // Floor Level wider
            ws['!cols'][15] = { wch: 30 }; // Classifications wider
            
            ws['!ref'] = `A1:P${subRow}`;
            
            XLSX.utils.book_append_sheet(wb, ws, 'HKS-BOMA-A');
        }
    </script>
</body>
</html>