<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HKS BOMA Tabulator</title>
    
    <!-- SheetJS Library for reading uploaded files -->
    <script src="https://cdn.sheetjs.com/xlsx-0.20.3/package/dist/xlsx.full.min.js"></script>
    <!-- ExcelJS Library for writing formatted Excel (preserves template styles) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/exceljs/4.4.0/exceljs.min.js"></script>
    
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        :root {
            --hks-grey: #7B797D;
            --hks-dark: #3a3a3a;
            --hks-light: #f5f5f5;
            --accent: #2196F3;
            --success: #4CAF50;
            --warning: #FF9800;
            --error: #f44336;
            --border: #e0e0e0;
        }
        
        body {
            font-family: Arial, sans-serif;
            background: linear-gradient(135deg, #f5f5f5 0%, #e8e8e8 100%);
            min-height: 100vh;
            padding: 20px;
            line-height: 1.6;
        }
        
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: var(--hks-grey);
            color: white;
            padding: 30px 40px;
            border-bottom: 4px solid var(--hks-dark);
        }
        
        .header h1 { font-size: 32px; font-weight: 600; margin-bottom: 8px; }
        .header p { opacity: 0.95; font-size: 15px; }
        
        .content { padding: 40px; }
        
        .step { margin-bottom: 40px; padding-bottom: 40px; border-bottom: 1px solid var(--border); }
        .step:last-child { border-bottom: none; }
        
        .step-header { display: flex; align-items: center; margin-bottom: 20px; }
        .step-number {
            width: 40px; height: 40px;
            background: var(--hks-grey);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            margin-right: 15px;
            font-size: 18px;
        }
        .step-title { font-size: 22px; color: var(--hks-dark); font-weight: 600; }
        
        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 50px;
            text-align: center;
            background: var(--hks-light);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        .upload-zone:hover { border-color: var(--accent); background: #e3f2fd; }
        .upload-icon { font-size: 56px; margin-bottom: 15px; }
        .upload-text { font-size: 18px; color: var(--hks-dark); margin-bottom: 8px; font-weight: 500; }
        input[type="file"] { display: none; }
        
        .file-info {
            display: none;
            align-items: center;
            gap: 15px;
            padding: 20px;
            background: #e8f5e9;
            border-radius: 8px;
            margin-top: 20px;
        }
        .file-info.active { display: flex; }
        
        .mapping-container {
            background: var(--hks-light);
            border-radius: 8px;
            padding: 25px;
            max-height: 500px;
            overflow-y: auto;
        }
        
        .floor-item {
            background: white;
            padding: 18px 20px;
            margin-bottom: 12px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            gap: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            transition: all 0.2s ease;
            cursor: grab;
        }
        .floor-item:hover {
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            transform: translateY(-1px);
        }
        .floor-item.dragging { opacity: 0.5; cursor: grabbing; }
        .floor-item.drag-over { border-top: 3px solid var(--accent); }
        
        .drag-handle {
            cursor: grab;
            padding: 5px;
            color: var(--hks-grey);
            font-size: 18px;
        }
        
        .floor-label {
            min-width: 200px;
            font-weight: 500;
            color: var(--hks-dark);
            padding: 8px 12px;
            background: var(--hks-light);
            border-radius: 4px;
        }
        
        .floor-input {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 15px;
            font-family: Arial, sans-serif;
        }
        .floor-input:focus {
            outline: none;
            border-color: var(--accent);
            box-shadow: 0 0 0 3px rgba(33, 150, 243, 0.1);
        }
        
        .floor-actions {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }
        .action-btn {
            padding: 8px 14px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s ease;
        }
        .action-btn:hover { background: var(--hks-light); }
        .action-btn.remove:hover { background: #ffebee; border-color: var(--error); color: var(--error); }
        
        .btn {
            padding: 14px 32px;
            border: none;
            border-radius: 6px;
            font-size: 16px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 10px;
        }
        .btn-primary { background: var(--accent); color: white; }
        .btn-primary:hover { background: #1976D2; transform: translateY(-2px); }
        .btn-success { background: var(--success); color: white; }
        .btn-success:hover { background: #45a049; transform: translateY(-2px); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }
        
        .hidden { display: none !important; }
        .info-box {
            background: #e3f2fd;
            border-left: 4px solid var(--accent);
            padding: 16px 20px;
            margin: 20px 0;
            border-radius: 4px;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: white;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid var(--border);
            text-align: center;
        }
        .stat-value {
            font-size: 32px;
            font-weight: 600;
            color: var(--hks-grey);
            margin-bottom: 5px;
        }
        
        .spinner {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        
        /* Project Info Styles */
        .project-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .project-field {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        .project-field label {
            font-weight: 500;
            color: var(--hks-dark);
            font-size: 14px;
        }
        .project-field input {
            padding: 12px 15px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 15px;
            font-family: Arial, sans-serif;
        }
        .project-field input:focus {
            outline: none;
            border-color: var(--accent);
        }
        .project-field .hint {
            font-size: 12px;
            color: #666;
        }
        
        /* Area Type Filter Styles */
        .area-type-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
            gap: 10px;
            margin: 15px 0;
        }
        .area-type-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 10px 12px;
            background: white;
            border: 1px solid var(--border);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
        }
        .area-type-item:hover {
            border-color: var(--accent);
            background: #f5f9ff;
        }
        .area-type-item input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        .area-type-item label {
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
        }
        .area-type-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        .area-type-buttons button {
            padding: 8px 16px;
            border: 1px solid var(--border);
            background: white;
            border-radius: 4px;
            cursor: pointer;
            font-size: 13px;
        }
        .area-type-buttons button:hover {
            background: var(--hks-light);
        }
        
        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }
        .modal-overlay.active {
            display: flex;
        }
        .modal {
            background: white;
            border-radius: 12px;
            max-width: 700px;
            width: 90%;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 10px 40px rgba(0,0,0,0.3);
        }
        .modal-header {
            background: var(--warning);
            color: white;
            padding: 20px 25px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        .modal-header.error {
            background: var(--error);
        }
        .modal-header h2 {
            font-size: 20px;
            font-weight: 600;
        }
        .modal-body {
            padding: 25px;
            max-height: 50vh;
            overflow-y: auto;
        }
        .modal-footer {
            padding: 20px 25px;
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }
        .btn-secondary {
            background: white;
            color: var(--hks-dark);
            border: 1px solid var(--border);
        }
        .btn-secondary:hover {
            background: var(--hks-light);
        }
        .btn-warning {
            background: var(--warning);
            color: white;
        }
        .btn-warning:hover {
            background: #f57c00;
        }
        
        /* Mismatch table */
        .mismatch-table {
            width: 100%;
            border-collapse: collapse;
            margin: 15px 0;
        }
        .mismatch-table th,
        .mismatch-table td {
            padding: 12px 15px;
            text-align: left;
            border-bottom: 1px solid var(--border);
        }
        .mismatch-table th {
            background: var(--hks-light);
            font-weight: 600;
            font-size: 13px;
            color: var(--hks-grey);
        }
        .mismatch-table td {
            font-size: 14px;
        }
        .mismatch-original {
            font-family: monospace;
            background: #fff3e0;
            padding: 4px 8px;
            border-radius: 4px;
            color: #e65100;
        }
        .mismatch-arrow {
            color: var(--hks-grey);
            font-size: 18px;
        }
        .mismatch-suggestion {
            font-family: monospace;
            background: #e8f5e9;
            padding: 4px 8px;
            border-radius: 4px;
            color: #2e7d32;
        }
        .match-percent {
            font-size: 12px;
            color: #666;
            margin-left: 8px;
        }
        
        /* Mapping select dropdown */
        .mapping-select {
            padding: 8px 12px;
            border: 2px solid var(--border);
            border-radius: 6px;
            font-size: 14px;
            min-width: 160px;
            background: white;
            cursor: pointer;
        }
        .mapping-select:focus {
            outline: none;
            border-color: var(--accent);
        }
        .custom-input {
            padding: 8px 12px;
            border: 2px solid var(--accent);
            border-radius: 6px;
            font-size: 14px;
            width: 140px;
            margin-left: 8px;
        }
        .revit-note {
            background: #fff8e1;
            border: 1px solid #ffcc02;
            border-radius: 6px;
            padding: 12px 15px;
            margin-bottom: 15px;
            font-size: 13px;
        }
        .revit-note strong {
            color: #f57c00;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><img src="https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/HKS-Logo-White_N2.png" alt="HKS" style="height: 0.82em; vertical-align: -0.05em; margin-right: 10px;">BOMA Tabulator</h1>
            <p>Convert Revit area exports to BOMA-compliant calculation spreadsheets</p>
        </div>
        
        <div class="content">
            <!-- Step 1: Upload -->
            <div class="step">
                <div class="step-header">
                    <div class="step-number">1</div>
                    <div class="step-title">Upload Revit Export</div>
                </div>
                <div class="upload-zone" id="uploadZone">
                    <div class="upload-icon">üìÅ</div>
                    <div class="upload-text">Click to browse or drag and drop</div>
                    <div class="upload-hint" style="font-size: 14px; color: #666;">Excel (.xlsx, .xls) or CSV</div>
                </div>
                <input type="file" id="fileInput" accept=".xlsx,.xls,.csv">
                <div class="file-info" id="fileInfo">
                    <span style="font-size: 32px; color: var(--success);">‚úì</span>
                    <div>
                        <h3 id="fileName" style="font-size: 16px; margin-bottom: 4px;"></h3>
                        <p id="fileDetails" style="font-size: 14px; color: #666;"></p>
                    </div>
                </div>
            </div>
            
            <!-- Step 2: Project Info -->
            <div class="step hidden" id="step2">
                <div class="step-header">
                    <div class="step-number">2</div>
                    <div class="step-title">Project Information</div>
                </div>
                <div class="info-box">
                    <p><strong>Optional:</strong> Enter project details below. Leave blank to use default values.</p>
                </div>
                <div class="project-info-grid">
                    <div class="project-field">
                        <label for="projectName">Project Name</label>
                        <input type="text" id="projectName" placeholder="Project Name">
                        <span class="hint">Default: "Project Name"</span>
                    </div>
                    <div class="project-field">
                        <label for="projectLocation">Location</label>
                        <input type="text" id="projectLocation" placeholder="City, State">
                        <span class="hint">Default: "City, State"</span>
                    </div>
                    <div class="project-field">
                        <label for="projectNumber">Project Number</label>
                        <input type="text" id="projectNumber" placeholder="00000.000">
                        <span class="hint">Default: "00000.000"</span>
                    </div>
                </div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn btn-primary" onclick="proceedToStep3()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 3: Area Type Filter -->
            <div class="step hidden" id="step3">
                <div class="step-header">
                    <div class="step-number">3</div>
                    <div class="step-title">Select Area Types</div>
                </div>
                <div class="info-box">
                    <p><strong>Filter:</strong> Uncheck any area types you want to exclude from the calculations.</p>
                </div>
                <div class="area-type-buttons">
                    <button onclick="selectAllAreaTypes()">‚úì Select All</button>
                    <button onclick="deselectAllAreaTypes()">‚úó Deselect All</button>
                </div>
                <div class="area-type-grid" id="areaTypeGrid"></div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn" style="background: var(--hks-grey); color: white; margin-right: 10px;" onclick="showStep(2)">
                        ‚Üê Back
                    </button>
                    <button class="btn btn-primary" onclick="proceedToStep4()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 4: Map Floors -->
            <div class="step hidden" id="step4">
                <div class="step-header">
                    <div class="step-number">4</div>
                    <div class="step-title">Map Building Floors</div>
                </div>
                <div class="info-box">
                    <p><strong>Instructions:</strong> Floors auto-sorted (Roof ‚Üí Floors ‚Üí Ground ‚Üí Basements). <strong>Drag-and-drop</strong> to reorder, or add/remove floors as needed.</p>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="totalLevels">0</div>
                        <div style="font-size: 13px; color: #666;">REVIT LEVELS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalRows">0</div>
                        <div style="font-size: 13px; color: #666;">DATA ROWS</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalFloors">0</div>
                        <div style="font-size: 13px; color: #666;">MAPPED FLOORS</div>
                    </div>
                </div>
                <div style="margin-bottom: 20px;">
                    <button class="btn" style="background: var(--hks-grey); color: white;" onclick="autoSortFloors()">
                        <span>‚áÖ</span> Auto-Sort
                    </button>
                    <button class="btn" style="background: white; color: var(--hks-dark); border: 1px solid var(--border);" onclick="resetMappings()">
                        <span>‚Ü∫</span> Reset
                    </button>
                </div>
                <div class="mapping-container" id="mappingContainer"></div>
                <div style="margin-top: 20px; text-align: right;">
                    <button class="btn" style="background: var(--hks-grey); color: white; margin-right: 10px;" onclick="showStep(3)">
                        ‚Üê Back
                    </button>
                    <button class="btn btn-primary" onclick="proceedToGenerate()">
                        Continue ‚Üí
                    </button>
                </div>
            </div>
            
            <!-- Step 5: Generate -->
            <div class="step hidden" id="step5">
                <div class="step-header">
                    <div class="step-number">5</div>
                    <div class="step-title">Generate BOMA Spreadsheet</div>
                </div>
                <div class="info-box" style="background: #fff3e0; border-left-color: var(--warning);">
                    <p><strong>Ready:</strong> Excel file will include BOMA Method A & B calculations with formulas, plus your Revit data (with typical floor duplications).</p>
                </div>
                <button class="btn btn-success" id="generateBtn" onclick="generateExcel()">
                    <span>üìä</span> Generate Excel with Formulas
                </button>
                <div style="margin-top: 20px;">
                    <button class="btn" style="background: var(--hks-grey); color: white;" onclick="showStep(4)">
                        ‚Üê Back
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Area Type Validation Modal -->
    <div class="modal-overlay" id="validationModal">
        <div class="modal">
            <div class="modal-header">
                <span style="font-size: 28px;">‚ö†Ô∏è</span>
                <h2>Area Type Mismatch Detected</h2>
            </div>
            <div class="modal-body">
                <div class="revit-note">
                    <strong>üí° Tip:</strong> Consider fixing these area type names in your Revit model before the next export to avoid this step in the future.
                </div>
                <p style="margin-bottom: 15px;">The following selected area types don't match expected BOMA categories and may cause formula errors:</p>
                <table class="mismatch-table" id="mismatchTable">
                    <thead>
                        <tr>
                            <th>Your Data</th>
                            <th></th>
                            <th>Map To</th>
                        </tr>
                    </thead>
                    <tbody id="mismatchTableBody">
                    </tbody>
                </table>
            </div>
            <div class="modal-footer">
                <button class="btn btn-secondary" onclick="closeValidationModal()">‚Üê Adjust Selection</button>
                <button class="btn btn-warning" onclick="applyMappingsAndProceed()">Apply Mappings & Continue ‚Üí</button>
            </div>
        </div>
    </div>
    
    <script>
        // Global state
        let workbookData = null;
        let rawData = [];
        let revitLevels = [];
        let floorMappings = [];
        let levelColumn = null;
        let originalMappings = [];
        let draggedIndex = null;
        let areaTypes = [];
        let selectedAreaTypes = [];
        let areaTypeMappings = {}; // Maps user's area types to BOMA categories
        
        // Expected BOMA area types
        const EXPECTED_AREA_TYPES = ['TA', 'TA-BALC', 'MVP', 'PA', 'BSA', 'BSA-DECK', 'FSA', 'BBC'];
        
        // Levenshtein distance for fuzzy matching
        function levenshteinDistance(a, b) {
            const matrix = [];
            for (let i = 0; i <= b.length; i++) {
                matrix[i] = [i];
            }
            for (let j = 0; j <= a.length; j++) {
                matrix[0][j] = j;
            }
            for (let i = 1; i <= b.length; i++) {
                for (let j = 1; j <= a.length; j++) {
                    if (b.charAt(i - 1) === a.charAt(j - 1)) {
                        matrix[i][j] = matrix[i - 1][j - 1];
                    } else {
                        matrix[i][j] = Math.min(
                            matrix[i - 1][j - 1] + 1,
                            matrix[i][j - 1] + 1,
                            matrix[i - 1][j] + 1
                        );
                    }
                }
            }
            return matrix[b.length][a.length];
        }
        
        // Calculate similarity percentage
        function getSimilarity(str1, str2) {
            const s1 = str1.toUpperCase().replace(/\s+/g, '');
            const s2 = str2.toUpperCase().replace(/\s+/g, '');
            const maxLen = Math.max(s1.length, s2.length);
            if (maxLen === 0) return 100;
            const distance = levenshteinDistance(s1, s2);
            return Math.round((1 - distance / maxLen) * 100);
        }
        
        // Find best matching expected type
        function findBestMatch(userType) {
            let bestMatch = null;
            let bestScore = 0;
            
            // Normalize for comparison
            const normalized = userType.toUpperCase().replace(/\s+/g, '').replace(/-+/g, '-');
            
            // Check for exact match first
            for (const expected of EXPECTED_AREA_TYPES) {
                if (normalized === expected) {
                    return { match: expected, score: 100 };
                }
            }
            
            // Fuzzy match
            for (const expected of EXPECTED_AREA_TYPES) {
                const score = getSimilarity(userType, expected);
                if (score > bestScore) {
                    bestScore = score;
                    bestMatch = expected;
                }
            }
            
            return { match: bestMatch, score: bestScore };
        }
        
        // Validate area types and return mismatches (only checks selected types)
        function validateAreaTypes() {
            const mismatches = [];
            
            for (const userType of selectedAreaTypes) {
                // Check for LITERAL exact match (case-insensitive only)
                const upperType = userType.toUpperCase();
                const isExactMatch = EXPECTED_AREA_TYPES.some(exp => exp.toUpperCase() === upperType);
                
                if (!isExactMatch) {
                    const { match, score } = findBestMatch(userType);
                    mismatches.push({
                        original: userType,
                        suggested: match,
                        score: score
                    });
                }
            }
            
            return mismatches;
        }
        
        // Show validation modal with mismatches
        function showValidationModal(mismatches) {
            const tbody = document.getElementById('mismatchTableBody');
            tbody.innerHTML = '';
            
            // Initialize mappings
            areaTypeMappings = {};
            
            mismatches.forEach((mismatch, idx) => {
                const row = document.createElement('tr');
                
                // Build dropdown options
                let options = EXPECTED_AREA_TYPES.map(type => 
                    `<option value="${type}" ${type === mismatch.suggested ? 'selected' : ''}>${type}</option>`
                ).join('');
                options += '<option value="__custom__">Add a custom Category</option>';
                
                row.innerHTML = `
                    <td><span class="mismatch-original">${mismatch.original}</span></td>
                    <td class="mismatch-arrow">‚Üí</td>
                    <td>
                        <select class="mapping-select" id="mapping_${idx}" onchange="handleMappingChange(${idx}, '${mismatch.original}', this.value)">
                            ${options}
                        </select>
                        <input type="text" class="custom-input" id="custom_${idx}" style="display:none;" 
                               placeholder="Custom name" onchange="handleCustomInput(${idx}, '${mismatch.original}', this.value)">
                        <span class="match-percent">${mismatch.score}% match</span>
                    </td>
                `;
                tbody.appendChild(row);
                
                // Initialize mapping with suggested value
                areaTypeMappings[mismatch.original] = mismatch.suggested;
            });
            
            document.getElementById('validationModal').classList.add('active');
        }
        
        // Handle dropdown change
        function handleMappingChange(idx, original, value) {
            const customInput = document.getElementById(`custom_${idx}`);
            
            if (value === '__custom__') {
                customInput.style.display = 'inline-block';
                customInput.focus();
                // Don't update mapping until they type something
            } else {
                customInput.style.display = 'none';
                areaTypeMappings[original] = value;
            }
        }
        
        // Handle custom input
        function handleCustomInput(idx, original, value) {
            if (value.trim()) {
                areaTypeMappings[original] = value.trim();
            }
        }
        
        // Close modal and go back to step 3
        function closeValidationModal() {
            document.getElementById('validationModal').classList.remove('active');
            // Stay on step 3 so user can adjust selections
        }
        
        // Apply mappings and continue to step 4
        function applyMappingsAndProceed() {
            // Verify all custom inputs have values
            for (const original in areaTypeMappings) {
                if (!areaTypeMappings[original]) {
                    alert('Please provide a mapping for all area types');
                    return;
                }
            }
            
            document.getElementById('validationModal').classList.remove('active');
            
            // Continue to step 4 (Map Building Floors)
            showStep(4);
        }
        
        // DOM elements
        const uploadZone = document.getElementById('uploadZone');
        const fileInput = document.getElementById('fileInput');
        const mappingContainer = document.getElementById('mappingContainer');
        
        // Upload handlers
        uploadZone.addEventListener('click', () => fileInput.click());
        uploadZone.addEventListener('dragover', e => { e.preventDefault(); uploadZone.style.borderColor = 'var(--accent)'; });
        uploadZone.addEventListener('dragleave', () => uploadZone.style.borderColor = '');
        uploadZone.addEventListener('drop', e => {
            e.preventDefault();
            uploadZone.style.borderColor = '';
            if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
        });
        fileInput.addEventListener('change', e => { if (e.target.files[0]) handleFile(e.target.files[0]); });
        
        function handleFile(file) {
            const ext = file.name.split('.').pop().toLowerCase();
            if (!['xlsx', 'xls', 'csv'].includes(ext)) {
                alert('Please upload Excel or CSV file');
                return;
            }
            
            const reader = new FileReader();
            reader.onload = e => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    workbookData = workbook;
                    
                    const firstSheet = workbook.Sheets[workbook.SheetNames[0]];
                    const jsonData = XLSX.utils.sheet_to_json(firstSheet, { defval: '' });
                    
                    if (jsonData.length === 0) {
                        alert('File is empty');
                        return;
                    }
                    
                    rawData = jsonData;
                    levelColumn = Object.keys(jsonData[0]).find(k => k.toLowerCase().includes('level'));
                    
                    if (!levelColumn) {
                        alert('No "Level" column found');
                        return;
                    }
                    
                    // Extract levels (allow short names like "P3")
                    revitLevels = [];
                    const seen = {};
                    jsonData.forEach(row => {
                        const level = row[levelColumn];
                        if (level && typeof level === 'string' && level.trim().length > 0 &&
                            !level.startsWith('(Instance)') && !seen[level]) {
                            seen[level] = true;
                            revitLevels.push(level);
                        }
                    });
                    
                    if (revitLevels.length === 0) {
                        alert('No valid levels found');
                        return;
                    }
                    
                    // Extract area types
                    const nameCol = Object.keys(jsonData[0]).find(k => k.toLowerCase() === 'name');
                    if (nameCol) {
                        const typeSet = new Set();
                        jsonData.forEach(row => {
                            const name = row[nameCol];
                            if (name && typeof name === 'string' && name.trim().length > 0) {
                                typeSet.add(name.trim());
                            }
                        });
                        areaTypes = Array.from(typeSet).sort();
                        selectedAreaTypes = [...areaTypes]; // All selected by default
                    }
                    
                    document.getElementById('fileName').textContent = file.name;
                    document.getElementById('fileDetails').textContent = `${revitLevels.length} levels ‚Ä¢ ${jsonData.length} rows ‚Ä¢ ${areaTypes.length} area types`;
                    document.getElementById('fileInfo').classList.add('active');
                    document.getElementById('totalLevels').textContent = revitLevels.length;
                    document.getElementById('totalRows').textContent = jsonData.length;
                    
                    initializeFloorMappings();
                    renderAreaTypes();
                    
                    // Clear any old mappings and proceed to step 2
                    areaTypeMappings = {};
                    showStep(2);
                } catch (error) {
                    alert('Error: ' + error.message);
                }
            };
            reader.readAsArrayBuffer(file);
        }
        
        // Area Type Functions
        function renderAreaTypes() {
            const grid = document.getElementById('areaTypeGrid');
            grid.innerHTML = '';
            
            areaTypes.forEach(type => {
                const div = document.createElement('div');
                div.className = 'area-type-item';
                const isChecked = selectedAreaTypes.includes(type);
                div.innerHTML = `
                    <input type="checkbox" id="at_${type}" ${isChecked ? 'checked' : ''} 
                           onchange="toggleAreaType('${type}', this.checked)">
                    <label for="at_${type}">${type}</label>
                `;
                grid.appendChild(div);
            });
        }
        
        function toggleAreaType(type, checked) {
            if (checked && !selectedAreaTypes.includes(type)) {
                selectedAreaTypes.push(type);
            } else if (!checked) {
                selectedAreaTypes = selectedAreaTypes.filter(t => t !== type);
            }
        }
        
        function selectAllAreaTypes() {
            selectedAreaTypes = [...areaTypes];
            renderAreaTypes();
        }
        
        function deselectAllAreaTypes() {
            selectedAreaTypes = [];
            renderAreaTypes();
        }
        
        function initializeFloorMappings() {
            floorMappings = revitLevels.map(level => ({
                revitLevel: level,
                buildingFloor: level,
                isNew: false
            }));
            
            // Auto-sort on load
            floorMappings.sort((a, b) => compareFloors(a.buildingFloor, b.buildingFloor));
            originalMappings = JSON.parse(JSON.stringify(floorMappings));
            renderFloorMappings();
        }
        
        function compareFloors(f1, f2) {
            const info1 = analyzeFloor(f1);
            const info2 = analyzeFloor(f2);
            if (info1.category !== info2.category) return info1.category - info2.category;
            if (info1.category === 3) return info2.number - info1.number; // Regular floors: high to low
            return info1.number - info2.number; // Basements: B1, B2, B3...
        }
        
        function analyzeFloor(name) {
            const n = name.toUpperCase();
            if (n.includes('ROOF')) return { category: 0, number: 0 };
            if (n.includes('PENTHOUSE') || n.includes('MECHANICAL') || n.includes('MACHINE') || n.includes('PH'))
                return { category: 1, number: 0 };
            if (n.includes('GROUND') || n.includes('LOBBY') || n.includes('MAIN') || n === 'G' || n === 'L')
                return { category: 4, number: 0 };
            
            const bMatch = n.match(/B[-\s]?(\d+)/i);
            if (bMatch) return { category: 5, number: parseInt(bMatch[1]) };
            
            const fMatch = n.match(/(?:LEVEL|L|P|FLOOR)[-\s]?(\d+)/i) || n.match(/^(\d+)/);
            if (fMatch) return { category: 3, number: parseInt(fMatch[1]) };
            
            return { category: 3, number: 0 };
        }
        
        function autoSortFloors() {
            floorMappings.sort((a, b) => compareFloors(a.buildingFloor, b.buildingFloor));
            renderFloorMappings();
        }
        
        function resetMappings() {
            if (confirm('Reset all changes?')) {
                floorMappings = JSON.parse(JSON.stringify(originalMappings));
                renderFloorMappings();
            }
        }
        
        function renderFloorMappings() {
            mappingContainer.innerHTML = '';
            floorMappings.forEach((m, i) => {
                const div = document.createElement('div');
                div.className = 'floor-item';
                div.draggable = true;
                div.dataset.index = i;
                
                div.innerHTML = `
                    <div class="drag-handle">‚ãÆ‚ãÆ</div>
                    <div class="floor-label">${m.isNew ? '(New)' : m.revitLevel}</div>
                    <div style="font-size: 24px; color: var(--hks-grey);">‚Üí</div>
                    <input type="text" class="floor-input" value="${m.buildingFloor}"
                           onchange="updateFloorName(${i}, this.value)"
                           placeholder="Floor name">
                    <div class="floor-actions">
                        <button class="action-btn" onclick="addFloorAbove(${i})">+ Above</button>
                        <button class="action-btn" onclick="addFloorBelow(${i})">+ Below</button>
                        <button class="action-btn remove" onclick="removeFloor(${i})">‚úï</button>
                    </div>
                `;
                
                div.addEventListener('dragstart', handleDragStart);
                div.addEventListener('dragover', handleDragOver);
                div.addEventListener('drop', handleDrop);
                div.addEventListener('dragend', handleDragEnd);
                
                mappingContainer.appendChild(div);
            });
            
            document.getElementById('totalFloors').textContent = floorMappings.length;
        }
        
        function handleDragStart(e) {
            draggedIndex = parseInt(this.dataset.index);
            this.classList.add('dragging');
        }
        
        function handleDragOver(e) {
            e.preventDefault();
            document.querySelectorAll('.floor-item').forEach(el => el.classList.remove('drag-over'));
            this.classList.add('drag-over');
        }
        
        function handleDrop(e) {
            e.preventDefault();
            const dropIndex = parseInt(this.dataset.index);
            if (draggedIndex !== null && draggedIndex !== dropIndex) {
                const item = floorMappings[draggedIndex];
                floorMappings.splice(draggedIndex, 1);
                floorMappings.splice(draggedIndex < dropIndex ? dropIndex - 1 : dropIndex, 0, item);
                renderFloorMappings();
            }
        }
        
        function handleDragEnd() {
            this.classList.remove('dragging');
            document.querySelectorAll('.floor-item').forEach(el => el.classList.remove('drag-over'));
            draggedIndex = null;
        }
        
        function updateFloorName(i, v) { floorMappings[i].buildingFloor = v.trim(); }
        
        function addFloorAbove(i) {
            const nextName = getNextFloorName(floorMappings[i].buildingFloor, 'above');
            // New floor inherits from the floor it was created from
            const sourceLevel = floorMappings[i].isNew ? floorMappings[i].sourceLevel : floorMappings[i].revitLevel;
            floorMappings.splice(i, 0, { 
                revitLevel: '(New)', 
                buildingFloor: nextName, 
                isNew: true,
                sourceLevel: sourceLevel
            });
            renderFloorMappings();
        }
        
        function addFloorBelow(i) {
            const nextName = getNextFloorName(floorMappings[i].buildingFloor, 'below');
            const sourceLevel = floorMappings[i].isNew ? floorMappings[i].sourceLevel : floorMappings[i].revitLevel;
            floorMappings.splice(i + 1, 0, { 
                revitLevel: '(New)', 
                buildingFloor: nextName, 
                isNew: true,
                sourceLevel: sourceLevel
            });
            renderFloorMappings();
        }
        
        function getNextFloorName(currentName, direction) {
            const num = currentName.match(/\d+/);
            if (!num) return currentName + ' (Copy)';
            
            const n = parseInt(num[0]);
            const digitCount = num[0].length;
            const prefix = currentName.substring(0, currentName.indexOf(num[0]));
            const suffix = currentName.substring(currentName.indexOf(num[0]) + num[0].length);
            
            const isBasement = currentName.toUpperCase().includes('B');
            let newNum;
            
            if (isBasement) {
                newNum = direction === 'above' ? n - 1 : n + 1;
            } else {
                newNum = direction === 'above' ? n + 1 : n - 1;
            }
            
            if (newNum <= 0) return currentName + ' (Copy)';
            
            // Preserve digit format (e.g., 06 stays 2 digits)
            let newNumStr = newNum.toString();
            if (newNumStr.length < digitCount) {
                newNumStr = newNumStr.padStart(digitCount, '0');
            }
            
            return prefix + newNumStr + suffix;
        }
        
        function removeFloor(i) {
            if (confirm('Remove this floor?')) {
                floorMappings.splice(i, 1);
                renderFloorMappings();
            }
        }
        
        function showStep(n) {
            document.querySelectorAll('.step').forEach(el => el.classList.add('hidden'));
            const stepId = n === 2 ? 'step2' : n === 3 ? 'step3' : n === 4 ? 'step4' : 'step5';
            document.getElementById(stepId).classList.remove('hidden');
        }
        
        function proceedToStep3() {
            showStep(3);
        }
        
        function proceedToStep4() {
            if (selectedAreaTypes.length === 0) {
                alert('Please select at least one area type');
                return;
            }
            
            // Validate selected area types
            const mismatches = validateAreaTypes();
            if (mismatches.length > 0) {
                // Show validation modal
                showValidationModal(mismatches);
            } else {
                // No mismatches, proceed directly
                areaTypeMappings = {};
                showStep(4);
            }
        }
        
        function proceedToGenerate() {
            const empty = floorMappings.filter(m => !m.buildingFloor.trim());
            if (empty.length > 0) {
                alert(`Please name all ${empty.length} floor(s)`);
                return;
            }
            showStep(5);
        }
        
        // Template URL - upload BOMA_Template.xlsx to GitHub for formatted output
        const TEMPLATE_URL = 'https://raw.githubusercontent.com/JasonCrist/BOMATabulator-PreRelease/main/BOMA_Template.xlsx';
        
        async function generateExcel() {
            const generateBtn = document.getElementById('generateBtn');
            try {
                generateBtn.disabled = true;
                generateBtn.innerHTML = '<span class="spinner"></span> Generating...';
                
                // Get project info with defaults
                const projectInfo = {
                    name: document.getElementById('projectName').value.trim() || 'Project Name',
                    location: document.getElementById('projectLocation').value.trim() || 'City, State',
                    number: document.getElementById('projectNumber').value.trim() || '00000.000'
                };
                
                // Build mapping lookup and source floor lookup
                const mappingLookup = {};  // Revit level -> Building floor
                const sourceFloorLookup = {};  // Building floor -> Source Revit level
                
                floorMappings.forEach(m => {
                    if (!m.isNew) {
                        mappingLookup[m.revitLevel] = m.buildingFloor;
                        sourceFloorLookup[m.buildingFloor] = m.revitLevel;
                    } else {
                        // New floor - use its stored sourceLevel
                        sourceFloorLookup[m.buildingFloor] = m.sourceLevel || null;
                    }
                });
                
                // For new floors without explicit source, find from neighbors
                floorMappings.forEach((m, idx) => {
                    if (m.isNew && !sourceFloorLookup[m.buildingFloor]) {
                        let sourceFloor = null;
                        
                        // Search BELOW first
                        for (let i = idx + 1; i < floorMappings.length; i++) {
                            if (!floorMappings[i].isNew) {
                                sourceFloor = floorMappings[i].revitLevel;
                                break;
                            }
                        }
                        
                        // Then search ABOVE
                        if (!sourceFloor) {
                            for (let i = idx - 1; i >= 0; i--) {
                                if (!floorMappings[i].isNew) {
                                    sourceFloor = floorMappings[i].revitLevel;
                                    break;
                                }
                            }
                        }
                        
                        if (sourceFloor) {
                            sourceFloorLookup[m.buildingFloor] = sourceFloor;
                        }
                    }
                });
                
                // Get name column
                const nameCol = Object.keys(rawData[0]).find(k => k.toLowerCase() === 'name');
                
                // Create EXPANDED mapped data - includes duplicated rows for typical floors
                const mappedData = [];
                
                // For each floor in the building (including new/typical floors)
                floorMappings.forEach(floorMapping => {
                    const buildingFloor = floorMapping.buildingFloor;
                    const sourceLevel = sourceFloorLookup[buildingFloor];
                    
                    if (!sourceLevel) return;
                    
                    // Get all data rows for the source level
                    rawData.forEach(row => {
                        const level = row[levelColumn];
                        if (level !== sourceLevel) return;
                        
                        const areaType = nameCol ? row[nameCol] : '';
                        
                        // Filter by selected area types
                        if (nameCol && !selectedAreaTypes.includes(areaType)) return;
                        
                        // Add row with the building floor name (not source level)
                        // Apply area type mapping if exists
                        const mappedAreaType = areaTypeMappings[areaType] || areaType || '';
                        
                        mappedData.push({
                            FloorMap: buildingFloor,
                            Name: mappedAreaType,
                            'Area Scheme Name': row['Area Scheme Name'] || 'BOMA 2024',
                            Area: parseFloat(row.Area) || 0
                        });
                    });
                });
                
                if (mappedData.length === 0) {
                    alert('No data to export. Check your area type selections.');
                    generateBtn.disabled = false;
                    generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
                    return;
                }
                
                // Get all floors from floorMappings
                const allFloors = floorMappings.map(m => m.buildingFloor);
                
                // Try template first, fall back to basic generation
                try {
                    await generateWithTemplate(allFloors, sourceFloorLookup, mappedData, projectInfo);
                    alert('‚úì BOMA Excel generated with formatting!\n\n' +
                          `‚Ä¢ HKS-BOMA-B - ${allFloors.length} floors\n` +
                          `‚Ä¢ HKS-BOMA-A - ${allFloors.length} floors\n` +
                          `‚Ä¢ Revit Data - ${mappedData.length} rows (with typical floor data)\n` +
                          '‚Ä¢ All formatting preserved! ‚úì');
                } catch (templateError) {
                    console.log('Template not available, using basic generation:', templateError.message);
                    
                    // Fall back to basic generation
                    const wb = XLSX.utils.book_new();
                    createBOMAMethodB(wb, allFloors, sourceFloorLookup, projectInfo);
                    createBOMAMethodA(wb, allFloors, sourceFloorLookup, projectInfo);
                    
                    const wsData = XLSX.utils.json_to_sheet(mappedData);
                    XLSX.utils.book_append_sheet(wb, wsData, 'Revit Data');
                    
                    const timestamp = new Date().toISOString().split('T')[0];
                    XLSX.writeFile(wb, `BOMA_Calculations_${timestamp}.xlsx`, { 
                        bookType: 'xlsx', 
                        cellFormula: true 
                    });
                    
                    alert('‚úì BOMA Excel generated!\n\n' +
                          `‚Ä¢ HKS-BOMA-B - ${allFloors.length} floors\n` +
                          `‚Ä¢ HKS-BOMA-A - ${allFloors.length} floors\n` +
                          `‚Ä¢ Revit Data - ${mappedData.length} rows\n\n` +
                          'Note: Upload BOMA_Template.xlsx to GitHub for formatted output');
                }
                
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
            } catch (error) {
                console.error(error);
                alert('Error: ' + error.message);
                generateBtn.disabled = false;
                generateBtn.innerHTML = '<span>üìä</span> Generate Excel with Formulas';
            }
        }
        
        async function generateWithTemplate(floors, sourceFloorLookup, mappedData, projectInfo) {
            // Fetch template from GitHub
            const response = await fetch(TEMPLATE_URL);
            if (!response.ok) {
                throw new Error('Template not found - upload BOMA_Template.xlsx to GitHub');
            }
            
            const arrayBuffer = await response.arrayBuffer();
            
            // Use ExcelJS to load and modify template (preserves formatting!)
            const workbook = new ExcelJS.Workbook();
            await workbook.xlsx.load(arrayBuffer);
            
            const wsB = workbook.getWorksheet('HKS-BOMA-B');
            const wsA = workbook.getWorksheet('HKS-BOMA-A');
            const wsData = workbook.getWorksheet('Revit Data');
            
            // Update project info (preserves cell formatting)
            const dateStr = new Date().toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
            
            if (wsB) {
                wsB.getCell('A1').value = projectInfo.name;
                wsB.getCell('A2').value = projectInfo.location;
                wsB.getCell('A3').value = `HKS Project# ${projectInfo.number}`;
                wsB.getCell('B2').value = dateStr;  // Date moved to B2
                
                // Populate BOMA-B data
                populateBOMAMethodB_ExcelJS(wsB, floors);
                
                // Remove blank rows: data ends at row (9+floors-1), subtotal at (9+floors), efficiency at (9+floors+1)
                // Template has rows through 70, so delete from (9+floors+2) through 70
                const keepUntilB = 9 + floors.length + 2; // Row after efficiency
                const deleteCountB = 71 - keepUntilB; // Delete up through row 70
                if (deleteCountB > 0) {
                    wsB.spliceRows(keepUntilB, deleteCountB);
                }
            }
            
            if (wsA) {
                wsA.getCell('A1').value = projectInfo.name;
                wsA.getCell('A2').value = projectInfo.location;
                wsA.getCell('A3').value = `HKS Project# ${projectInfo.number}`;
                wsA.getCell('B2').value = dateStr;  // Date moved to B2
                
                // Populate BOMA-A data
                populateBOMAMethodA_ExcelJS(wsA, floors);
                
                // Remove blank rows: same logic as BOMA-B
                const keepUntilA = 9 + floors.length + 2; // Row after efficiency
                const deleteCountA = 71 - keepUntilA; // Delete up through row 70
                if (deleteCountA > 0) {
                    wsA.spliceRows(keepUntilA, deleteCountA);
                }
            }
            
            if (wsData) {
                // Populate Revit Data (starting at row 2)
                mappedData.forEach((row, idx) => {
                    const rowNum = idx + 2;
                    wsData.getCell(`A${rowNum}`).value = row.FloorMap;
                    wsData.getCell(`B${rowNum}`).value = row.Name;
                    wsData.getCell(`C${rowNum}`).value = row['Area Scheme Name'];
                    wsData.getCell(`D${rowNum}`).value = row.Area;
                });
            }
            
            // Generate buffer and download
            const buffer = await workbook.xlsx.writeBuffer();
            const blob = new Blob([buffer], { type: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            const timestamp = new Date().toISOString().split('T')[0];
            a.download = `BOMA_Calculations_${timestamp}.xlsx`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        function populateBOMAMethodB_ExcelJS(ws, floors) {
            const startRow = 9;
            const lastDataRow = startRow + floors.length - 1;
            const subTotalRow = startRow + floors.length; // Subtotal immediately after data
            
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                
                // Set values and formulas (formatting is preserved from template)
                ws.getCell(`A${row}`).value = floor;
                ws.getCell(`B${row}`).value = { formula: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$D:$D)` };
                ws.getCell(`C${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")` };
                ws.getCell(`D${row}`).value = { formula: `B${row}-C${row}` };
                ws.getCell(`E${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")` };
                ws.getCell(`F${row}`).value = { formula: `D${row}-E${row}` };
                ws.getCell(`G${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")` };
                ws.getCell(`H${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")` };
                ws.getCell(`I${row}`).value = { formula: `IF($H$${subTotalRow}=0,0,($F$${subTotalRow}-$G$${subTotalRow})/$H$${subTotalRow})` };
                ws.getCell(`J${row}`).value = { formula: `G${row}+(H${row}*I${row})` };
            });
            
            // Write TOTALS formulas at the row immediately after data
            // (Don't overwrite A - preserve template's label by copying from row 69)
            ws.getCell(`A${subTotalRow}`).value = ws.getCell('A69').value || 'TOTALS';
            ws.getCell(`B${subTotalRow}`).value = { formula: `SUM(B${startRow}:B${lastDataRow})` };
            ws.getCell(`C${subTotalRow}`).value = { formula: `SUM(C${startRow}:C${lastDataRow})` };
            ws.getCell(`D${subTotalRow}`).value = { formula: `SUM(D${startRow}:D${lastDataRow})` };
            ws.getCell(`E${subTotalRow}`).value = { formula: `SUM(E${startRow}:E${lastDataRow})` };
            ws.getCell(`F${subTotalRow}`).value = { formula: `SUM(F${startRow}:F${lastDataRow})` };
            ws.getCell(`G${subTotalRow}`).value = { formula: `SUM(G${startRow}:G${lastDataRow})` };
            ws.getCell(`H${subTotalRow}`).value = { formula: `SUM(H${startRow}:H${lastDataRow})` };
            ws.getCell(`I${subTotalRow}`).value = { formula: `IF(H${subTotalRow}=0,0,(F${subTotalRow}-G${subTotalRow})/H${subTotalRow})` };
            ws.getCell(`J${subTotalRow}`).value = { formula: `SUM(J${startRow}:J${lastDataRow})` };
            
            // Copy formatting from template's subtotal row (69) to new subtotal row
            for (let col = 1; col <= 10; col++) {
                const templateCell = ws.getCell(69, col);
                const newCell = ws.getCell(subTotalRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
            
            // Copy Efficiency row from 70 to new position (subTotalRow + 1)
            const efficiencyRow = subTotalRow + 1;
            ws.getCell(`A${efficiencyRow}`).value = ws.getCell('A70').value || 'Efficiency';
            ws.getCell(`J${efficiencyRow}`).value = { formula: `IF(D${subTotalRow}=0,0,J${subTotalRow}/D${subTotalRow})` };
            // Copy formatting
            for (let col = 1; col <= 10; col++) {
                const templateCell = ws.getCell(70, col);
                const newCell = ws.getCell(efficiencyRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
        }
        
        function populateBOMAMethodA_ExcelJS(ws, floors) {
            const startRow = 9;
            const lastDataRow = startRow + floors.length - 1;
            const subTotalRow = startRow + floors.length; // Subtotal immediately after data
            
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                
                ws.getCell(`A${row}`).value = floor;
                ws.getCell(`B${row}`).value = { formula: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$D:$D)` };
                ws.getCell(`C${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")` };
                ws.getCell(`D${row}`).value = { formula: `B${row}-C${row}` };
                ws.getCell(`E${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")` };
                ws.getCell(`F${row}`).value = { formula: `D${row}-E${row}` };
                ws.getCell(`G${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")` };
                ws.getCell(`H${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")` };
                ws.getCell(`I${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA")+SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA-DECK")` };
                ws.getCell(`J${row}`).value = { formula: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"FSA")+SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BBC")` };
                ws.getCell(`K${row}`).value = { formula: `IF(H${row}=0,0,(H${row}+J${row})/H${row})` };
                ws.getCell(`L${row}`).value = { formula: `H${row}*K${row}` };
                ws.getCell(`M${row}`).value = { formula: `IF(($F$${subTotalRow}-$G$${subTotalRow}-$I$${subTotalRow})=0,0,($F$${subTotalRow}-$G$${subTotalRow})/($F$${subTotalRow}-$G$${subTotalRow}-$I$${subTotalRow}))` };
                ws.getCell(`N${row}`).value = { formula: `G${row}+(L${row}*M${row})` };
                ws.getCell(`O${row}`).value = { formula: `IF(H${row}=0,0,N${row}/H${row})` };
            });
            
            // Write TOTAL formulas at the row immediately after data
            ws.getCell(`A${subTotalRow}`).value = ws.getCell('A69').value || 'TOTAL';
            ws.getCell(`B${subTotalRow}`).value = { formula: `SUM(B${startRow}:B${lastDataRow})` };
            ws.getCell(`C${subTotalRow}`).value = { formula: `SUM(C${startRow}:C${lastDataRow})` };
            ws.getCell(`D${subTotalRow}`).value = { formula: `SUM(D${startRow}:D${lastDataRow})` };
            ws.getCell(`E${subTotalRow}`).value = { formula: `SUM(E${startRow}:E${lastDataRow})` };
            ws.getCell(`F${subTotalRow}`).value = { formula: `SUM(F${startRow}:F${lastDataRow})` };
            ws.getCell(`G${subTotalRow}`).value = { formula: `SUM(G${startRow}:G${lastDataRow})` };
            ws.getCell(`H${subTotalRow}`).value = { formula: `SUM(H${startRow}:H${lastDataRow})` };
            ws.getCell(`I${subTotalRow}`).value = { formula: `SUM(I${startRow}:I${lastDataRow})` };
            ws.getCell(`J${subTotalRow}`).value = { formula: `SUM(J${startRow}:J${lastDataRow})` };
            ws.getCell(`K${subTotalRow}`).value = { formula: `IF(H${subTotalRow}=0,0,(H${subTotalRow}+J${subTotalRow})/H${subTotalRow})` };
            ws.getCell(`L${subTotalRow}`).value = { formula: `SUM(L${startRow}:L${lastDataRow})` };
            ws.getCell(`M${subTotalRow}`).value = { formula: `IF((F${subTotalRow}-G${subTotalRow}-I${subTotalRow})=0,0,(F${subTotalRow}-G${subTotalRow})/(F${subTotalRow}-G${subTotalRow}-I${subTotalRow}))` };
            ws.getCell(`N${subTotalRow}`).value = { formula: `SUM(N${startRow}:N${lastDataRow})` };
            // Note: Column O (Load Factor A) has no total - it's floor-specific
            
            // Copy formatting from template's subtotal row (69) to new subtotal row
            for (let col = 1; col <= 15; col++) {
                const templateCell = ws.getCell(69, col);
                const newCell = ws.getCell(subTotalRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
            
            // Copy Efficiency row from 70 to new position (subTotalRow + 1)
            const efficiencyRow = subTotalRow + 1;
            ws.getCell(`A${efficiencyRow}`).value = ws.getCell('A70').value || 'Efficiency';
            ws.getCell(`N${efficiencyRow}`).value = { formula: `IF(D${subTotalRow}=0,0,N${subTotalRow}/D${subTotalRow})` };
            // Copy formatting
            for (let col = 1; col <= 15; col++) {
                const templateCell = ws.getCell(70, col);
                const newCell = ws.getCell(efficiencyRow, col);
                if (templateCell.style) {
                    newCell.style = JSON.parse(JSON.stringify(templateCell.style));
                }
            }
        }
        
        function createBOMAMethodB(wb, floors, sourceFloorLookup, projectInfo) {
            const ws = {};
            const dateStr = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', month: 'long', day: 'numeric' 
            });
            
            // Row 1 - Project header
            ws['A1'] = { t: 's', v: projectInfo.name };
            ws['J1'] = { t: 's', v: 'Preliminary Global Summary Of Areas' };
            
            // Row 2 - Location and date
            ws['A2'] = { t: 's', v: projectInfo.location };
            ws['J2'] = { t: 's', v: dateStr };
            ws['K2'] = { t: 's', v: 'Per BOMA/ANSI Z65.1 2024-Method B (Modified HKS)' };
            
            // Row 3 - Project number
            ws['A3'] = { t: 's', v: `HKS Project# ${projectInfo.number}` };
            
            // Row 4 - Column letters
            const headers4 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K'];
            headers4.forEach(h => {
                ws[h + '4'] = { t: 's', v: h };
            });
            
            // Row 5 - Formula descriptions
            const formulas5 = ['Input', 'Input', 'Input', 'B-C', 'Input', 'D-E', 'Input', 'Input', '(Œ£F-Œ£G)/Œ£H', 'G+(H*I)', 'Calculation'];
            formulas5.forEach((f, i) => {
                ws[String.fromCharCode(65 + i) + '5'] = { t: 's', v: f };
            });
            
            // Row 6 - Abbreviations
            const abbrev6 = ['PA', 'MVP', 'TA-BALC', 'TA', '', '', '', '', '', '', 'Area Plan Abbreviations & Wall Priorities'];
            abbrev6.forEach((a, i) => {
                if (a) ws[String.fromCharCode(65 + i) + '6'] = { t: 's', v: a };
            });
            
            // Row 7 - Full descriptions
            const desc7 = [
                '(Parking)', 'GSF', 'Stairs, Shafts, & Elevators', 'GSF-MVP (No Load Factor)',
                'Unenclosed Tenant Areas (Balconies)', 'Tenant Area (AKA Occupant Areas)',
                '', '', '', '', 'Explanation / Definitions'
            ];
            desc7.forEach((d, i) => {
                if (d) ws[String.fromCharCode(65 + i) + '7'] = { t: 's', v: d };
            });
            
            // Row 8 - Column headers
            const headers8 = [
                'Floor Level', 'Boundary Areas (Overall)', 'Boundary Area Exclusions',
                'Boundary Areas (Office)', 'Major Vertical Penetrations', 'Floor Rentable Area',
                'Non-Allocated Tenant Areas (Balconies)', 'Tenant / Occupant Useable Areas',
                'Load Factor B', 'Rentable Area', 'BOMA 2024 Space Classifications'
            ];
            headers8.forEach((h, i) => {
                ws[String.fromCharCode(65 + i) + '8'] = { t: 's', v: h };
            });
            
            // Data rows starting at row 9
            const startRow = 9;
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                
                // Formulas reference the building floor name (data is duplicated in Revit Data)
                ws['A' + rowStr] = { t: 's', v: floor };
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$D:$D)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                
                const subRowRef = (startRow + floors.length).toString();
                ws['I' + rowStr] = { t: 'n', f: `IF($H$${subRowRef}=0,0,($F$${subRowRef}-$G$${subRowRef})/$H$${subRowRef})`, z: '0.0000' };
                ws['J' + rowStr] = { t: 'n', f: `G${rowStr}+(H${rowStr}*I${rowStr})`, z: '#,##0' };
            });
            
            // Subtotal row
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(F${subRow}-G${subRow})/H${subRow})`, z: '0.0000' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            
            ws['!cols'] = [
                { wch: 25 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 },
                { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 12 }, { wch: 30 }
            ];
            
            ws['!ref'] = `A1:K${subRow}`;
            
            XLSX.utils.book_append_sheet(wb, ws, 'HKS-BOMA-B');
        }
        
        function createBOMAMethodA(wb, floors, sourceFloorLookup, projectInfo) {
            const ws = {};
            const dateStr = new Date().toLocaleDateString('en-US', { 
                year: 'numeric', month: 'long', day: 'numeric' 
            });
            
            // Header rows
            ws['A1'] = { t: 's', v: projectInfo.name };
            ws['O1'] = { t: 's', v: 'Preliminary Global Summary Of Areas' };
            
            ws['A2'] = { t: 's', v: projectInfo.location };
            ws['O2'] = { t: 's', v: dateStr };
            ws['P2'] = { t: 's', v: 'Per BOMA/ANSI Z65.1 2024-Method A (Modified HKS)' };
            
            ws['A3'] = { t: 's', v: `HKS Project# ${projectInfo.number}` };
            
            // Row 4 - Column letters
            const headers4 = ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P'];
            headers4.forEach(h => {
                ws[h + '4'] = { t: 's', v: h };
            });
            
            // Row 5 - Formula descriptions
            const formulas5 = ['Input', 'Input', 'Input', 'B-C', 'Input', 'D-E', 'Input', 'Input', 'Input', 'Input', '(H+J)/H', 'H*K', '(Œ£F-Œ£G)/(Œ£F-Œ£G-Œ£I)', 'G+(L*M)', 'N/H', 'Calculation'];
            formulas5.forEach((f, i) => {
                ws[String.fromCharCode(65 + i) + '5'] = { t: 's', v: f };
            });
            
            // Row 6 - Abbreviations
            const abbrev6 = ['PA', 'MVP', 'TA-BALC', 'TA', 'BSA', 'FSA', '', '', '', '', '', '', '', '', '', 'Area Plan Abbreviations'];
            abbrev6.forEach((a, i) => {
                if (a) ws[String.fromCharCode(65 + i) + '6'] = { t: 's', v: a };
            });
            
            // Row 8 - Column headers
            const headers8 = [
                'Floor Level', 'Boundary Areas (Overall)', 'Boundary Area Exclusions',
                'Boundary Areas (Office)', 'Major Vertical Penetrations', 'Floor Rentable Area',
                'Non-Allocated Tenant Areas (Balconies)', 'Occupant Useable Areas',
                'Building Service Areas', 'Floor Service Area', 'Floor Allocation Ratio',
                'Floor Allocation', 'Building Allocation Ratio', 'Rentable Area',
                'Load Factor A', 'BOMA 2024 Space Classifications'
            ];
            headers8.forEach((h, i) => {
                ws[String.fromCharCode(65 + i) + '8'] = { t: 's', v: h };
            });
            
            // Data rows
            const startRow = 9;
            floors.forEach((floor, idx) => {
                const row = startRow + idx;
                const rowStr = row.toString();
                const subRowRef = (startRow + floors.length).toString();
                
                ws['A' + rowStr] = { t: 's', v: floor };
                ws['B' + rowStr] = { t: 'n', f: `SUMIF('Revit Data'!$A:$A,"${floor}",'Revit Data'!$D:$D)`, z: '#,##0' };
                ws['C' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"PA")`, z: '#,##0' };
                ws['D' + rowStr] = { t: 'n', f: `B${rowStr}-C${rowStr}`, z: '#,##0' };
                ws['E' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"MVP")`, z: '#,##0' };
                ws['F' + rowStr] = { t: 'n', f: `D${rowStr}-E${rowStr}`, z: '#,##0' };
                ws['G' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA-BALC")`, z: '#,##0' };
                ws['H' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"TA")`, z: '#,##0' };
                ws['I' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA")+SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BSA-DECK")`, z: '#,##0' };
                ws['J' + rowStr] = { t: 'n', f: `SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"FSA")+SUMIFS('Revit Data'!$D:$D,'Revit Data'!$A:$A,"${floor}",'Revit Data'!$B:$B,"BBC")`, z: '#,##0' };
                ws['K' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,(H${rowStr}+J${rowStr})/H${rowStr})`, z: '0.0000' };
                ws['L' + rowStr] = { t: 'n', f: `H${rowStr}*K${rowStr}`, z: '#,##0' };
                ws['M' + rowStr] = { t: 'n', f: `IF(($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef})=0,0,($F$${subRowRef}-$G$${subRowRef})/($F$${subRowRef}-$G$${subRowRef}-$I$${subRowRef}))`, z: '0.0000' };
                ws['N' + rowStr] = { t: 'n', f: `G${rowStr}+(L${rowStr}*M${rowStr})`, z: '#,##0' };
                ws['O' + rowStr] = { t: 'n', f: `IF(H${rowStr}=0,0,N${rowStr}/H${rowStr})`, z: '0.0000' };
            });
            
            // Subtotal row
            const subRow = startRow + floors.length;
            const lastDataRow = subRow - 1;
            
            ws['A' + subRow] = { t: 's', v: 'SubTotal' };
            ws['B' + subRow] = { t: 'n', f: `SUM(B${startRow}:B${lastDataRow})`, z: '#,##0' };
            ws['C' + subRow] = { t: 'n', f: `SUM(C${startRow}:C${lastDataRow})`, z: '#,##0' };
            ws['D' + subRow] = { t: 'n', f: `SUM(D${startRow}:D${lastDataRow})`, z: '#,##0' };
            ws['E' + subRow] = { t: 'n', f: `SUM(E${startRow}:E${lastDataRow})`, z: '#,##0' };
            ws['F' + subRow] = { t: 'n', f: `SUM(F${startRow}:F${lastDataRow})`, z: '#,##0' };
            ws['G' + subRow] = { t: 'n', f: `SUM(G${startRow}:G${lastDataRow})`, z: '#,##0' };
            ws['H' + subRow] = { t: 'n', f: `SUM(H${startRow}:H${lastDataRow})`, z: '#,##0' };
            ws['I' + subRow] = { t: 'n', f: `SUM(I${startRow}:I${lastDataRow})`, z: '#,##0' };
            ws['J' + subRow] = { t: 'n', f: `SUM(J${startRow}:J${lastDataRow})`, z: '#,##0' };
            ws['K' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,(H${subRow}+J${subRow})/H${subRow})`, z: '0.0000' };
            ws['L' + subRow] = { t: 'n', f: `SUM(L${startRow}:L${lastDataRow})`, z: '#,##0' };
            ws['M' + subRow] = { t: 'n', f: `IF((F${subRow}-G${subRow}-I${subRow})=0,0,(F${subRow}-G${subRow})/(F${subRow}-G${subRow}-I${subRow}))`, z: '0.0000' };
            ws['N' + subRow] = { t: 'n', f: `SUM(N${startRow}:N${lastDataRow})`, z: '#,##0' };
            ws['O' + subRow] = { t: 'n', f: `IF(H${subRow}=0,0,N${subRow}/H${subRow})`, z: '0.0000' };
            
            ws['!cols'] = Array(16).fill({ wch: 11 });
            ws['!cols'][0] = { wch: 25 };
            ws['!cols'][15] = { wch: 30 };
            
            ws['!ref'] = `A1:P${subRow}`;
            
            XLSX.utils.book_append_sheet(wb, ws, 'HKS-BOMA-A');
        }
    </script>
</body>
</html>
